<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Barista: AirPcap functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Barista
   &#160;<span id="projectnumber">1.0.0 (Americano)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__airpcapfuncs.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AirPcap functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf2d048644aee82a6d60d14b694d8ea75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaf2d048644aee82a6d60d14b694d8ea75">AirpcapGetVersion</a> (PUINT VersionMajor, PUINT VersionMinor, PUINT VersionRev, PUINT VersionBuild)</td></tr>
<tr class="memdesc:gaf2d048644aee82a6d60d14b694d8ea75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string with the API version.  <a href="#gaf2d048644aee82a6d60d14b694d8ea75">More...</a><br/></td></tr>
<tr class="separator:gaf2d048644aee82a6d60d14b694d8ea75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa659ca1646d89a1b5e79d2496b7dedce"><td class="memItemLeft" align="right" valign="top">PCHAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaa659ca1646d89a1b5e79d2496b7dedce">AirpcapGetLastError</a> (PAirpcapHandle AdapterHandle)</td></tr>
<tr class="memdesc:gaa659ca1646d89a1b5e79d2496b7dedce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last error related to the specified handle.  <a href="#gaa659ca1646d89a1b5e79d2496b7dedce">More...</a><br/></td></tr>
<tr class="separator:gaa659ca1646d89a1b5e79d2496b7dedce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2d7dad3d18925221a312b24372d604"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604">AirpcapGetDeviceList</a> (<a class="el" href="struct__AirpcapDeviceDescription.html">PAirpcapDeviceDescription</a> *PPAllDevs, PCHAR Ebuf)</td></tr>
<tr class="memdesc:ga4f2d7dad3d18925221a312b24372d604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of available devices.  <a href="#ga4f2d7dad3d18925221a312b24372d604">More...</a><br/></td></tr>
<tr class="separator:ga4f2d7dad3d18925221a312b24372d604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ee2864654ca3fbd1f5c3a3e72efa992"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga2ee2864654ca3fbd1f5c3a3e72efa992">AirpcapFreeDeviceList</a> (<a class="el" href="struct__AirpcapDeviceDescription.html">PAirpcapDeviceDescription</a> PAllDevs)</td></tr>
<tr class="memdesc:ga2ee2864654ca3fbd1f5c3a3e72efa992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a list of devices returned by <a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604" title="Return the list of available devices. ">AirpcapGetDeviceList()</a>  <a href="#ga2ee2864654ca3fbd1f5c3a3e72efa992">More...</a><br/></td></tr>
<tr class="separator:ga2ee2864654ca3fbd1f5c3a3e72efa992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a24296462970dd8915aae1039b2bb3"><td class="memItemLeft" align="right" valign="top">PAirpcapHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga69a24296462970dd8915aae1039b2bb3">AirpcapOpen</a> (PCHAR DeviceName, PCHAR Ebuf)</td></tr>
<tr class="memdesc:ga69a24296462970dd8915aae1039b2bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an adapter.  <a href="#ga69a24296462970dd8915aae1039b2bb3">More...</a><br/></td></tr>
<tr class="separator:ga69a24296462970dd8915aae1039b2bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75106eb2f2ce0a528b37bbc5b90f63af"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga75106eb2f2ce0a528b37bbc5b90f63af">AirpcapClose</a> (PAirpcapHandle AdapterHandle)</td></tr>
<tr class="memdesc:ga75106eb2f2ce0a528b37bbc5b90f63af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an adapter.  <a href="#ga75106eb2f2ce0a528b37bbc5b90f63af">More...</a><br/></td></tr>
<tr class="separator:ga75106eb2f2ce0a528b37bbc5b90f63af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7db92c5b0267f46400e7127dc8314ce"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gab7db92c5b0267f46400e7127dc8314ce">AirpcapSetMonitorMode</a> (PAirpcapHandle AdapterHandle, BOOL MonitorModeEnabled)</td></tr>
<tr class="memdesc:gab7db92c5b0267f46400e7127dc8314ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the monitor mode for the specified adapter.  <a href="#gab7db92c5b0267f46400e7127dc8314ce">More...</a><br/></td></tr>
<tr class="separator:gab7db92c5b0267f46400e7127dc8314ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e84ba83c2b840ba9daeb7f36db5d0c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga73e84ba83c2b840ba9daeb7f36db5d0c">AirpcapGetMonitorMode</a> (PAirpcapHandle AdapterHandle, PBOOL PMonitorModeEnabled)</td></tr>
<tr class="memdesc:ga73e84ba83c2b840ba9daeb7f36db5d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the specified adapter is in monitor mode.  <a href="#ga73e84ba83c2b840ba9daeb7f36db5d0c">More...</a><br/></td></tr>
<tr class="separator:ga73e84ba83c2b840ba9daeb7f36db5d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1adedd10e4f67674277dcab81fe0fd14"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga1adedd10e4f67674277dcab81fe0fd14">AirpcapSetLinkType</a> (PAirpcapHandle AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga141f7efbb58f0a6a71a77721624e70b1">AirpcapLinkType</a> NewLinkType)</td></tr>
<tr class="memdesc:ga1adedd10e4f67674277dcab81fe0fd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the link type of an adapter.  <a href="#ga1adedd10e4f67674277dcab81fe0fd14">More...</a><br/></td></tr>
<tr class="separator:ga1adedd10e4f67674277dcab81fe0fd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b03cf3c1d8cac0baf85e14add7dcdd7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga0b03cf3c1d8cac0baf85e14add7dcdd7">AirpcapGetLinkType</a> (PAirpcapHandle AdapterHandle, PAirpcapLinkType PLinkType)</td></tr>
<tr class="memdesc:ga0b03cf3c1d8cac0baf85e14add7dcdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the link type of the specified adapter.  <a href="#ga0b03cf3c1d8cac0baf85e14add7dcdd7">More...</a><br/></td></tr>
<tr class="separator:ga0b03cf3c1d8cac0baf85e14add7dcdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cc811fb136709135e5fc7de26d2096"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga14cc811fb136709135e5fc7de26d2096">AirpcapSetFcsPresence</a> (PAirpcapHandle AdapterHandle, BOOL IsFcsPresent)</td></tr>
<tr class="memdesc:ga14cc811fb136709135e5fc7de26d2096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the adapter on whether to include the MAC Frame Check Sequence in the captured packets.  <a href="#ga14cc811fb136709135e5fc7de26d2096">More...</a><br/></td></tr>
<tr class="separator:ga14cc811fb136709135e5fc7de26d2096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bece61b28b40593f5cd3f03422f3659"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga8bece61b28b40593f5cd3f03422f3659">AirpcapGetFcsPresence</a> (PAirpcapHandle AdapterHandle, PBOOL PIsFcsPresent)</td></tr>
<tr class="memdesc:ga8bece61b28b40593f5cd3f03422f3659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the specified adapter includes the MAC Frame Check Sequence in the captured packets.  <a href="#ga8bece61b28b40593f5cd3f03422f3659">More...</a><br/></td></tr>
<tr class="separator:ga8bece61b28b40593f5cd3f03422f3659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17c18f94e959905de419a7f065829fd"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gae17c18f94e959905de419a7f065829fd">AirpcapSetFcsValidation</a> (PAirpcapHandle AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga9a5d9c63fb74f8adf053b2851f1e3aac">AirpcapValidationType</a> ValidationType)</td></tr>
<tr class="memdesc:gae17c18f94e959905de419a7f065829fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the adapter to accept or drop frames with an incorrect Frame Check sequence (FCS).  <a href="#gae17c18f94e959905de419a7f065829fd">More...</a><br/></td></tr>
<tr class="separator:gae17c18f94e959905de419a7f065829fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a96792b5aa752b92cd4b14a87067e5"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaa9a96792b5aa752b92cd4b14a87067e5">AirpcapGetFcsValidation</a> (PAirpcapHandle AdapterHandle, PAirpcapValidationType ValidationType)</td></tr>
<tr class="memdesc:gaa9a96792b5aa752b92cd4b14a87067e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified adapter is configured to capture frames with incorrect an incorrect Frame Check Sequence (FCS).  <a href="#gaa9a96792b5aa752b92cd4b14a87067e5">More...</a><br/></td></tr>
<tr class="separator:gaa9a96792b5aa752b92cd4b14a87067e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a13dcb21b6afe5f9eb3497864a0eb1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga12a13dcb21b6afe5f9eb3497864a0eb1">AirpcapSetDeviceKeys</a> (PAirpcapHandle AdapterHandle, <a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a> KeysCollection)</td></tr>
<tr class="memdesc:ga12a13dcb21b6afe5f9eb3497864a0eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the list of decryption keys that the driver is going to use with the specified device.  <a href="#ga12a13dcb21b6afe5f9eb3497864a0eb1">More...</a><br/></td></tr>
<tr class="separator:ga12a13dcb21b6afe5f9eb3497864a0eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c26b2b40b14eaba8b52d964d9d33b8"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga46c26b2b40b14eaba8b52d964d9d33b8">AirpcapGetDeviceKeys</a> (PAirpcapHandle AdapterHandle, <a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a> KeysCollection, PUINT PKeysCollectionSize)</td></tr>
<tr class="memdesc:ga46c26b2b40b14eaba8b52d964d9d33b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of decryption keys in the driver that are currently associated with the specified device.  <a href="#ga46c26b2b40b14eaba8b52d964d9d33b8">More...</a><br/></td></tr>
<tr class="separator:ga46c26b2b40b14eaba8b52d964d9d33b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bbee0e89e2ec706c680148f1163d4d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gab4bbee0e89e2ec706c680148f1163d4d">AirpcapSetDriverKeys</a> (PAirpcapHandle AdapterHandle, <a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a> KeysCollection)</td></tr>
<tr class="memdesc:gab4bbee0e89e2ec706c680148f1163d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global list of decryption keys that the driver is going to use with all the devices.  <a href="#gab4bbee0e89e2ec706c680148f1163d4d">More...</a><br/></td></tr>
<tr class="separator:gab4bbee0e89e2ec706c680148f1163d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4c3345b7ff9a57e0379d55cd0ba575c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gae4c3345b7ff9a57e0379d55cd0ba575c">AirpcapGetDriverKeys</a> (PAirpcapHandle AdapterHandle, <a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a> KeysCollection, PUINT PKeysCollectionSize)</td></tr>
<tr class="memdesc:gae4c3345b7ff9a57e0379d55cd0ba575c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global list of decryption keys in the driver that are associated with all the devices.  <a href="#gae4c3345b7ff9a57e0379d55cd0ba575c">More...</a><br/></td></tr>
<tr class="separator:gae4c3345b7ff9a57e0379d55cd0ba575c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205739adab5b532ba07d342636a6506c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga205739adab5b532ba07d342636a6506c">AirpcapSetDecryptionState</a> (PAirpcapHandle AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga1524eaffea4a4ff173bf52c9da577fb8">AirpcapDecryptionState</a> Enable)</td></tr>
<tr class="memdesc:ga205739adab5b532ba07d342636a6506c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on or off the decryption of the incoming frames with the <b>adapter-specific</b> keys.  <a href="#ga205739adab5b532ba07d342636a6506c">More...</a><br/></td></tr>
<tr class="separator:ga205739adab5b532ba07d342636a6506c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga035b302cd3ad1fc6c95f71bf4534e538"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga035b302cd3ad1fc6c95f71bf4534e538">AirpcapGetDecryptionState</a> (PAirpcapHandle AdapterHandle, PAirpcapDecryptionState PEnable)</td></tr>
<tr class="memdesc:ga035b302cd3ad1fc6c95f71bf4534e538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if this open instance is configured to perform the decryption of the incoming frames with the <b>adapter-specific</b> keys.  <a href="#ga035b302cd3ad1fc6c95f71bf4534e538">More...</a><br/></td></tr>
<tr class="separator:ga035b302cd3ad1fc6c95f71bf4534e538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f354cc8ec91e5715d30d2b2b343528"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga73f354cc8ec91e5715d30d2b2b343528">AirpcapSetDriverDecryptionState</a> (PAirpcapHandle AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga1524eaffea4a4ff173bf52c9da577fb8">AirpcapDecryptionState</a> Enable)</td></tr>
<tr class="memdesc:ga73f354cc8ec91e5715d30d2b2b343528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on or off the decryption of the incoming frames with the <b>global driver</b> set of keys.  <a href="#ga73f354cc8ec91e5715d30d2b2b343528">More...</a><br/></td></tr>
<tr class="separator:ga73f354cc8ec91e5715d30d2b2b343528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63fed593c1a47fa2b599519e9da1996f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga63fed593c1a47fa2b599519e9da1996f">AirpcapGetDriverDecryptionState</a> (PAirpcapHandle AdapterHandle, PAirpcapDecryptionState PEnable)</td></tr>
<tr class="memdesc:ga63fed593c1a47fa2b599519e9da1996f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if this open instance is configured to perform the decryption of the incoming frames with the <b>global driver</b> set of keys.  <a href="#ga63fed593c1a47fa2b599519e9da1996f">More...</a><br/></td></tr>
<tr class="separator:ga63fed593c1a47fa2b599519e9da1996f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4803da4b6f886e8f8bb5bd4ee89d03"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel</a> (PAirpcapHandle AdapterHandle, UINT Channel)</td></tr>
<tr class="memdesc:ga4c4803da4b6f886e8f8bb5bd4ee89d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radio channel of a device.  <a href="#ga4c4803da4b6f886e8f8bb5bd4ee89d03">More...</a><br/></td></tr>
<tr class="separator:ga4c4803da4b6f886e8f8bb5bd4ee89d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ad4be210887ac0f6d70bc077fac780"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga51ad4be210887ac0f6d70bc077fac780">AirpcapGetDeviceChannel</a> (PAirpcapHandle AdapterHandle, PUINT PChannel)</td></tr>
<tr class="memdesc:ga51ad4be210887ac0f6d70bc077fac780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the radio channel of a device.  <a href="#ga51ad4be210887ac0f6d70bc077fac780">More...</a><br/></td></tr>
<tr class="separator:ga51ad4be210887ac0f6d70bc077fac780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae09c4d22f8bc55b4c3410e55b6d26395"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gae09c4d22f8bc55b4c3410e55b6d26395">AirpcapSetKernelBuffer</a> (PAirpcapHandle AdapterHandle, UINT BufferSize)</td></tr>
<tr class="memdesc:gae09c4d22f8bc55b4c3410e55b6d26395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the kernel packet buffer for this adapter.  <a href="#gae09c4d22f8bc55b4c3410e55b6d26395">More...</a><br/></td></tr>
<tr class="separator:gae09c4d22f8bc55b4c3410e55b6d26395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79d33b20e36a978e7fce0592af76571e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga79d33b20e36a978e7fce0592af76571e">AirpcapGetKernelBufferSize</a> (PAirpcapHandle AdapterHandle, PUINT PSizeBytes)</td></tr>
<tr class="memdesc:ga79d33b20e36a978e7fce0592af76571e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the kernel packet buffer for this adapter.  <a href="#ga79d33b20e36a978e7fce0592af76571e">More...</a><br/></td></tr>
<tr class="separator:ga79d33b20e36a978e7fce0592af76571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591ddeab1e4c8883e18d127724d1d041"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga591ddeab1e4c8883e18d127724d1d041">AirpcapStoreCurConfigAsAdapterDefault</a> (PAirpcapHandle AdapterHandle)</td></tr>
<tr class="memdesc:ga591ddeab1e4c8883e18d127724d1d041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the configuration of the specified adapter in the registry, so that it becomes the default for this adapter.  <a href="#ga591ddeab1e4c8883e18d127724d1d041">More...</a><br/></td></tr>
<tr class="separator:ga591ddeab1e4c8883e18d127724d1d041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7f10fcd12b5263dc4af0ec83db03cf"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaae7f10fcd12b5263dc4af0ec83db03cf">AirpcapSetFilter</a> (PAirpcapHandle AdapterHandle, PVOID Instructions, UINT Len)</td></tr>
<tr class="memdesc:gaae7f10fcd12b5263dc4af0ec83db03cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the BPF kernel filter for an adapter.  <a href="#gaae7f10fcd12b5263dc4af0ec83db03cf">More...</a><br/></td></tr>
<tr class="separator:gaae7f10fcd12b5263dc4af0ec83db03cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6efbcac4adb18bc915ce902aced05134"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga6efbcac4adb18bc915ce902aced05134">AirpcapGetMacAddress</a> (PAirpcapHandle AdapterHandle, <a class="el" href="struct__AirpcapMacAddress.html">PAirpcapMacAddress</a> PMacAddress)</td></tr>
<tr class="memdesc:ga6efbcac4adb18bc915ce902aced05134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the MAC address of an adapter.  <a href="#ga6efbcac4adb18bc915ce902aced05134">More...</a><br/></td></tr>
<tr class="separator:ga6efbcac4adb18bc915ce902aced05134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276dc280fc36d07e40519a8606383f86"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy</a> (PAirpcapHandle AdapterHandle, UINT MinToCopy)</td></tr>
<tr class="memdesc:ga276dc280fc36d07e40519a8606383f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mintocopy parameter for an open adapter.  <a href="#ga276dc280fc36d07e40519a8606383f86">More...</a><br/></td></tr>
<tr class="separator:ga276dc280fc36d07e40519a8606383f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb1ee017987102c70ea7da012e67559"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga3bb1ee017987102c70ea7da012e67559">AirpcapGetReadEvent</a> (PAirpcapHandle AdapterHandle, HANDLE *PReadEvent)</td></tr>
<tr class="memdesc:ga3bb1ee017987102c70ea7da012e67559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an event that is signaled when that is signalled when packets are available in the kernel buffer (see <a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy()</a>).  <a href="#ga3bb1ee017987102c70ea7da012e67559">More...</a><br/></td></tr>
<tr class="separator:ga3bb1ee017987102c70ea7da012e67559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ea5971235f478c0bd3bd2ce1c63a10"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga28ea5971235f478c0bd3bd2ce1c63a10">AirpcapRead</a> (PAirpcapHandle AdapterHandle, PBYTE <a class="el" href="structBuffer.html">Buffer</a>, UINT BufSize, PUINT PReceievedBytes)</td></tr>
<tr class="memdesc:ga28ea5971235f478c0bd3bd2ce1c63a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a user-provided buffer with zero or more packets that have been captured on the referenced adapter.  <a href="#ga28ea5971235f478c0bd3bd2ce1c63a10">More...</a><br/></td></tr>
<tr class="separator:ga28ea5971235f478c0bd3bd2ce1c63a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70134a6b7dddf5b6227740474c0d1b95"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga70134a6b7dddf5b6227740474c0d1b95">AirpcapWrite</a> (PAirpcapHandle AdapterHandle, PCHAR TxPacket, ULONG PacketLen)</td></tr>
<tr class="memdesc:ga70134a6b7dddf5b6227740474c0d1b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a packet.  <a href="#ga70134a6b7dddf5b6227740474c0d1b95">More...</a><br/></td></tr>
<tr class="separator:ga70134a6b7dddf5b6227740474c0d1b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1de7c3fe8cb1d0c52147aac5eae356"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaeb1de7c3fe8cb1d0c52147aac5eae356">AirpcapGetStats</a> (PAirpcapHandle AdapterHandle, <a class="el" href="struct__AirpcapStats.html">PAirpcapStats</a> PStats)</td></tr>
<tr class="memdesc:gaeb1de7c3fe8cb1d0c52147aac5eae356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get per-adapter WinPcap-compatible capture statistics.  <a href="#gaeb1de7c3fe8cb1d0c52147aac5eae356">More...</a><br/></td></tr>
<tr class="separator:gaeb1de7c3fe8cb1d0c52147aac5eae356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f6300567098e09294d3e0c93a7a4f4"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga15f6300567098e09294d3e0c93a7a4f4">AirpcapGetLedsNumber</a> (PAirpcapHandle AdapterHandle, PUINT NumberOfLeds)</td></tr>
<tr class="memdesc:ga15f6300567098e09294d3e0c93a7a4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of LEDs the referenced adapter has available.  <a href="#ga15f6300567098e09294d3e0c93a7a4f4">More...</a><br/></td></tr>
<tr class="separator:ga15f6300567098e09294d3e0c93a7a4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf225a0632d8e077ef431ae994b8b16f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaaf225a0632d8e077ef431ae994b8b16f">AirpcapTurnLedOn</a> (PAirpcapHandle AdapterHandle, UINT LedNumber)</td></tr>
<tr class="memdesc:gaaf225a0632d8e077ef431ae994b8b16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on one of the adapter's LEDs.  <a href="#gaaf225a0632d8e077ef431ae994b8b16f">More...</a><br/></td></tr>
<tr class="separator:gaaf225a0632d8e077ef431ae994b8b16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb0fe78ab2fa519d66aca8b22f6cad49"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gafb0fe78ab2fa519d66aca8b22f6cad49">AirpcapTurnLedOff</a> (PAirpcapHandle AdapterHandle, UINT LedNumber)</td></tr>
<tr class="memdesc:gafb0fe78ab2fa519d66aca8b22f6cad49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off one of the adapter's LEDs.  <a href="#gafb0fe78ab2fa519d66aca8b22f6cad49">More...</a><br/></td></tr>
<tr class="separator:gafb0fe78ab2fa519d66aca8b22f6cad49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0677e7ff539c4a0bb1154e2710bb371f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga0677e7ff539c4a0bb1154e2710bb371f">AirpcapSetDeviceChannelEx</a> (PAirpcapHandle AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga602d987914eb1db696ab8a7fada8f12b">AirpcapChannelInfo</a> ChannelInfo)</td></tr>
<tr class="memdesc:ga0677e7ff539c4a0bb1154e2710bb371f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the channel of a device through its radio frequency. In case of 802.11n enabled devices, it sets the extension channel, if used.  <a href="#ga0677e7ff539c4a0bb1154e2710bb371f">More...</a><br/></td></tr>
<tr class="separator:ga0677e7ff539c4a0bb1154e2710bb371f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga637e2f5d7f27ac7d3eaf75ed73d57910"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga637e2f5d7f27ac7d3eaf75ed73d57910">AirpcapGetDeviceChannelEx</a> (PAirpcapHandle AdapterHandle, <a class="el" href="struct__AirpcapChannelInfo.html">PAirpcapChannelInfo</a> PChannelInfo)</td></tr>
<tr class="memdesc:ga637e2f5d7f27ac7d3eaf75ed73d57910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the channel of a device through its radiofrequency. In case of 802.11n enabled devices, it gets the extension channel, if in use.  <a href="#ga637e2f5d7f27ac7d3eaf75ed73d57910">More...</a><br/></td></tr>
<tr class="separator:ga637e2f5d7f27ac7d3eaf75ed73d57910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b94f343249d70d598e4b0db5c6561c1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga9b94f343249d70d598e4b0db5c6561c1">AirpcapGetDeviceSupportedChannels</a> (PAirpcapHandle AdapterHandle, <a class="el" href="struct__AirpcapChannelInfo.html">PAirpcapChannelInfo</a> *ppChannelInfo, PUINT pNumChannelInfo)</td></tr>
<tr class="memdesc:ga9b94f343249d70d598e4b0db5c6561c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of supported channels for a given device. In case of a 802.11n capable device, information related to supported extension channels is also reported.  <a href="#ga9b94f343249d70d598e4b0db5c6561c1">More...</a><br/></td></tr>
<tr class="separator:ga9b94f343249d70d598e4b0db5c6561c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8f1697634241f447f934de4d6cf065"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga4f8f1697634241f447f934de4d6cf065">AirpcapConvertFrequencyToChannel</a> (UINT Frequency, PUINT PChannel, PAirpcapChannelBand PBand)</td></tr>
<tr class="memdesc:ga4f8f1697634241f447f934de4d6cf065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a given frequency to the corresponding channel.  <a href="#ga4f8f1697634241f447f934de4d6cf065">More...</a><br/></td></tr>
<tr class="separator:ga4f8f1697634241f447f934de4d6cf065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab99902bf7bfc60b6bc47f92785298d5"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaab99902bf7bfc60b6bc47f92785298d5">AirpcapConvertChannelToFrequency</a> (UINT Channel, PUINT PFrequency)</td></tr>
<tr class="memdesc:gaab99902bf7bfc60b6bc47f92785298d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a given channel to the corresponding frequency.  <a href="#gaab99902bf7bfc60b6bc47f92785298d5">More...</a><br/></td></tr>
<tr class="separator:gaab99902bf7bfc60b6bc47f92785298d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga75106eb2f2ce0a528b37bbc5b90f63af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID AirpcapClose </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab99902bf7bfc60b6bc47f92785298d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapConvertChannelToFrequency </td>
          <td>(</td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>PFrequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Channel</td><td>Channel number to be converted. </td></tr>
    <tr><td class="paramname">PFrequency</td><td>Pointer to a user-supplied variable that will contain the channel frequency in MHz on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, i.e. the given channel number exists. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f8f1697634241f447f934de4d6cf065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapConvertFrequencyToChannel </td>
          <td>(</td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>Frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>PChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PAirpcapChannelBand&#160;</td>
          <td class="paramname"><em>PBand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Frequency</td><td>Frequency of the channel, in MHz. </td></tr>
    <tr><td class="paramname">PChannel</td><td>Pointer to a user-supplied variable that will contain the channel number on success. </td></tr>
    <tr><td class="paramname">PBand</td><td>Pointer to a user-supplied variable that will contain the band (a or b/g) of the given channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, i.e. the frequency corresponds to a valid a or b/g channel. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ee2864654ca3fbd1f5c3a3e72efa992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID AirpcapFreeDeviceList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__AirpcapDeviceDescription.html">PAirpcapDeviceDescription</a>&#160;</td>
          <td class="paramname"><em>PAllDevs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PAllDevs</td><td>Head of the list of devices returned by <a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604">AirpcapGetDeviceList()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga035b302cd3ad1fc6c95f71bf4534e538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDecryptionState </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PAirpcapDecryptionState&#160;</td>
          <td class="paramname"><em>PEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PEnable</td><td>Pointer to a user supplied variable that will contain the decryption configuration. See PAirpcapDecryptionState for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation is succesful. FALSE otherwise.</dd></dl>
<p>The adapter-specific decryption keys can be configured with the <a class="el" href="group__airpcapfuncs.html#ga12a13dcb21b6afe5f9eb3497864a0eb1">AirpcapSetDeviceKeys()</a> function. </p>
<dl class="section note"><dt>Note</dt><dd>By default, the driver is configured with <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51ad4be210887ac0f6d70bc077fac780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceChannel </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>PChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PChannel</td><td>Pointer to a user-supplied variable into which the function will copy the currently configured radio channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>The list of available channels can be retrieved with <a class="el" href="group__airpcapfuncs.html#ga9b94f343249d70d598e4b0db5c6561c1">AirpcapGetDeviceSupportedChannels()</a>. The default channel setting is 6.</p>
<dl class="section note"><dt>Note</dt><dd>this is a device-related function: when you change the channel from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga637e2f5d7f27ac7d3eaf75ed73d57910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceChannelEx </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapChannelInfo.html">PAirpcapChannelInfo</a>&#160;</td>
          <td class="paramname"><em>PChannelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PChannelInfo</td><td>Pointer to a user-supplied variable into which the function will copy the currently configured channel information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this is a device-related function: when you change the channel from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46c26b2b40b14eaba8b52d964d9d33b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceKeys </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a>&#160;</td>
          <td class="paramname"><em>KeysCollection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>PKeysCollectionSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to an open adapter instance. </td></tr>
    <tr><td class="paramname">KeysCollection</td><td>User-allocated PAirpcapKeysCollection structure that will be filled with the keys. </td></tr>
    <tr><td class="paramname">PKeysCollectionSize</td><td><b>IN:</b> pointer to a user-allocated variable that contains the length of the KeysCollection structure, in bytes. <b>OUT:</b> amount of data moved by the driver in the buffer pointed by KeysBuffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation is succesful. If an error occurs, the return value is FALSE and KeysCollectionSize is zero. If the provided buffer is too small to contain the keys, the return value is FALSE and KeysCollectionSize contains the needed KeysCollection length, in bytes. If the device doesn't have any decryption key configured, the return value is TRUE, and KeysCollectionSize will be zero.</dd></dl>
<p>This function returns the <b>adapter-specific</b> set of keys. These keys are used by the specified adapter only, and not by other airpcap devices besides the specified one.</p>
<p>The AirPcap driver is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames to the application. The driver supports, for every device, multiple keys at the same time.</p>
<p>The configured decryption keys are device-specific, therefore <a class="el" href="group__airpcapfuncs.html#ga46c26b2b40b14eaba8b52d964d9d33b8" title="Returns the list of decryption keys in the driver that are currently associated with the specified de...">AirpcapGetDeviceKeys()</a> will return a different set of keys when called on different devices.</p>
<p>At this time, the only supported decryption method is WEP. </p>

</div>
</div>
<a class="anchor" id="ga4f2d7dad3d18925221a312b24372d604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__AirpcapDeviceDescription.html">PAirpcapDeviceDescription</a> *&#160;</td>
          <td class="paramname"><em>PPAllDevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PCHAR&#160;</td>
          <td class="paramname"><em>Ebuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PPAllDevs</td><td>Address to a caller allocated pointer. On success this pointer will receive the head of a list of available devices. </td></tr>
    <tr><td class="paramname">Ebuf</td><td>String that will contain error information if FALSE is returned. The size of the string must be AIRPCAP_ERRBUF_SIZE bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success. FALSE is returned on failure, in which case Ebuf is filled in with an appropriate error message.</dd></dl>
<p>Here's a snippet of code that shows how to use <a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604" title="Return the list of available devices. ">AirpcapGetDeviceList()</a>:</p>
<div class="fragment"><div class="line">CHAR Ebuf[<a class="code" href="group__airpcapdefs.html#gaefe7d8c60ddf650b04dd74211d39cf4d">AIRPCAP_ERRBUF_SIZE</a>];</div>
<div class="line"><a class="code" href="struct__AirpcapDeviceDescription.html">AirpcapDeviceDescription</a> *Desc, *tDesc;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604">AirpcapGetDeviceList</a>(&amp;Desc, Ebuf) == -1)</div>
<div class="line">{</div>
<div class="line">  printf(<span class="stringliteral">&quot;Unable to get the list of devices: %s\n&quot;</span>, Ebuf);</div>
<div class="line">  <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(tDesc = Desc; tDesc; tDesc = tDesc-&gt;<a class="code" href="struct__AirpcapDeviceDescription.html#a8f0cb0cd405251c40de2ea36a8091397">next</a>)</div>
<div class="line">{</div>
<div class="line">  printf(<span class="stringliteral">&quot;%u) %s (%s)\n&quot;</span>,</div>
<div class="line">  ++i,</div>
<div class="line">  tDesc-&gt;<a class="code" href="struct__AirpcapDeviceDescription.html#a193450584a7b39149f6e516dbb55f30a">Name</a>,</div>
<div class="line">  tDesc-&gt;<a class="code" href="struct__AirpcapDeviceDescription.html#ac18beae9bacc3550127fd2d4d47cd2de">Description</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__airpcapfuncs.html#ga2ee2864654ca3fbd1f5c3a3e72efa992">AirpcapFreeDeviceList</a>(Desc);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga9b94f343249d70d598e4b0db5c6561c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceSupportedChannels </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapChannelInfo.html">PAirpcapChannelInfo</a> *&#160;</td>
          <td class="paramname"><em>ppChannelInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>pNumChannelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Every control channel is listed multiple times, one for each different supported extension channel. For example channel 6 (2437MHz) is usually listed three times:</p>
<ul>
<li><b>Frequency 2437 Extension +1</b>. Control channel is 6, extension channel is 10.</li>
<li><b>Frequency 2437 Extension 0</b>. Control channel is 6, no extension channel is used (20MHz channel and legacy mode).</li>
<li><b>Frequency 2437 Extension -1</b>. Control channel is 6, extension channel is 2. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">ppChannelInfo</td><td>Pointer to a user-supplied variable that will point to an array of supported channel. Such list must not be freed by the caller </td></tr>
    <tr><td class="paramname">pNumChannelInfo</td><td>Number of channels returned in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The supported channels are not listed in any specific order. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga63fed593c1a47fa2b599519e9da1996f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDriverDecryptionState </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PAirpcapDecryptionState&#160;</td>
          <td class="paramname"><em>PEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PEnable</td><td>Pointer to a user supplied variable that will contain the decryption configuration. See PAirpcapDecryptionState for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation is succesful. FALSE otherwise.</dd></dl>
<p>The global decryption keys can be configured with the <a class="el" href="group__airpcapfuncs.html#gab4bbee0e89e2ec706c680148f1163d4d">AirpcapSetDriverKeys()</a> function. </p>
<dl class="section note"><dt>Note</dt><dd>By default, the driver is configured with <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae4c3345b7ff9a57e0379d55cd0ba575c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDriverKeys </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a>&#160;</td>
          <td class="paramname"><em>KeysCollection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>PKeysCollectionSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to an open adapter instance. </td></tr>
    <tr><td class="paramname">KeysCollection</td><td>User-allocated PAirpcapKeysCollection structure that will be filled with the keys. </td></tr>
    <tr><td class="paramname">PKeysCollectionSize</td><td><b>IN:</b> pointer to a user-allocated variable that contains the length of the KeysCollection structure, in bytes. <b>OUT:</b> amount of data moved by the driver in the buffer pointed by KeysBuffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation is succesful. If an error occurs, the return value is FALSE and KeysCollectionSize is zero. If the provided buffer is too small to contain the keys, the return value is FALSE and KeysCollectionSize contains the needed KeysCollection length, in bytes. If the device doesn't have any decryption key configured, the return value is TRUE, and KeysCollectionSize will be zero.</dd></dl>
<p>This function returns the <b>global driver</b> set of keys. These keys will be used by all the adapters plugged in the machine.</p>
<p>The AirPcap driver is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames to the application.</p>
<p>At this time, the only supported decryption method is WEP. </p>

</div>
</div>
<a class="anchor" id="ga8bece61b28b40593f5cd3f03422f3659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetFcsPresence </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PBOOL&#160;</td>
          <td class="paramname"><em>PIsFcsPresent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PIsFcsPresent</td><td>User-provided variable that will be set to true if the adapter is including the FCS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation is successful. FALSE otherwise.</dd></dl>
<p>In the default configuration, the adatper has FCS inclusion turned on. The MAC Frame Check Sequence is 4 bytes and is located at the end of the 802.11 packet, with both AIRPCAP_LT_802_11 and AIRPCAP_LT_802_11_PLUS_RADIO link types. When the FCS inclusion is turned on, and if the link type is AIRPCAP_LT_802_11_PLUS_RADIO, the radiotap header that precedes each frame has two additional fields at the end: Padding and FCS. These two fields are not present when FCS inclusion is off. </p>

</div>
</div>
<a class="anchor" id="gaa9a96792b5aa752b92cd4b14a87067e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetFcsValidation </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PAirpcapValidationType&#160;</td>
          <td class="paramname"><em>ValidationType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">ValidationType</td><td>Pointer to a user supplied variable that will contain the type of validation the driver will perform. See the documentation of <a class="el" href="group__airpcapdefs.html#ga9a5d9c63fb74f8adf053b2851f1e3aac">AirpcapValidationType</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation is succesful. FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>By default, the driver is configured in <a class="el" href="group__airpcapdefs.html#gga055511accfcb2816fce9782d9b57ad50a4c6ecd77d205c51cf150189e5358ec95">AIRPCAP_VT_ACCEPT_EVERYTHING</a> mode. </dd></dl>

</div>
</div>
<a class="anchor" id="ga79d33b20e36a978e7fce0592af76571e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetKernelBufferSize </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>PSizeBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PSizeBytes</td><td>User-allocated variable that will be filled with the size of the kernel buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>Every AirPcap open instance has an associated kernel buffer, whose default size is 1 Mbyte. This function can be used to get the size of this buffer. </p>

</div>
</div>
<a class="anchor" id="gaa659ca1646d89a1b5e79d2496b7dedce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCHAR AirpcapGetLastError </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to an open adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string with the last error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga15f6300567098e09294d3e0c93a7a4f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetLedsNumber </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>NumberOfLeds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">NumberOfLeds</td><td>Number of LEDs available on this adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b03cf3c1d8cac0baf85e14add7dcdd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetLinkType </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PAirpcapLinkType&#160;</td>
          <td class="paramname"><em>PLinkType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PLinkType</td><td>Pointer to a caller allocated AirpcapLinkType variable that will contain the link type of the adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>the "link type" determines how the driver will encode the packets captured from the network. Aircap supports two link types:</p>
<ul>
<li>AIRPCAP_LT_802_11, to capture 802.11 frames (including control frames) without any power information. Look at the Capture_no_radio example application in the developer's pack for a reference on how to decode 802.11 frames with this link type.</li>
<li>AIRPCAP_LT_802_11_PLUS_RADIO, to capture 802.11 frames (including control frames) with a radiotap header that contains power and channel information. More information about the radiotap header can be found int the radiotap section. Moreover, the "Capture_radio" example application in the developer's pack can be used as a reference on how to decode 802.11 frames with radiotap headers. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga6efbcac4adb18bc915ce902aced05134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetMacAddress </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapMacAddress.html">PAirpcapMacAddress</a>&#160;</td>
          <td class="paramname"><em>PMacAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PMacAddress</td><td>Pointer to a user allocated MAC address. The size of this buffer needs to be at least 6 bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73e84ba83c2b840ba9daeb7f36db5d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetMonitorMode </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PBOOL&#160;</td>
          <td class="paramname"><em>PMonitorModeEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PMonitorModeEnabled</td><td>User-provided variable that will be set to true if the adapter is in monitor mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation is successful. FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When an adapter is plugged into the system, it's always configured with monitor mode ON. The monitor mode configuration is not stored persistently, so if you want to turn monitor mode off, you will need to do it every time you open the adapter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3bb1ee017987102c70ea7da012e67559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetReadEvent </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE *&#160;</td>
          <td class="paramname"><em>PReadEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PReadEvent</td><td>Pointer to a user-supplied handle that in which the read event will be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>the event is signalled when at least mintocopy bytes are present in the kernel buffer (see <a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy()</a>). This event can be used by WaitForSingleObject() and WaitForMultipleObjects() to create blocking behavior when reading packets from one or more adapters (see <a class="el" href="group__airpcapfuncs.html#ga28ea5971235f478c0bd3bd2ce1c63a10">AirpcapRead()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb1de7c3fe8cb1d0c52147aac5eae356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetStats </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapStats.html">PAirpcapStats</a>&#160;</td>
          <td class="paramname"><em>PStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">PStats</td><td>pointer to a user-allocated AirpcapStats structure that will be filled with statistical information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2d048644aee82a6d60d14b694d8ea75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AirpcapGetVersion </td>
          <td>(</td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>VersionMajor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>VersionMinor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>VersionRev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>VersionBuild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VersionMajor</td><td>Pointer to a variable that will be filled with the major version number. </td></tr>
    <tr><td class="paramname">VersionMinor</td><td>Pointer to a variable that will be filled with the minor version number. </td></tr>
    <tr><td class="paramname">VersionRev</td><td>Pointer to a variable that will be filled with the revision number. </td></tr>
    <tr><td class="paramname">VersionBuild</td><td>Pointer to a variable that will be filled with the build number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga69a24296462970dd8915aae1039b2bb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PAirpcapHandle AirpcapOpen </td>
          <td>(</td>
          <td class="paramtype">PCHAR&#160;</td>
          <td class="paramname"><em>DeviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PCHAR&#160;</td>
          <td class="paramname"><em>Ebuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceName</td><td>Name of the device to open. Use <a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604">AirpcapGetDeviceList()</a> to get the list of devices. </td></tr>
    <tr><td class="paramname">Ebuf</td><td>String that will contain error information in case of failure. The size of the string must be AIRPCAP_ERRBUF_SIZE bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A PAirpcapHandle handle on success. NULL is returned on failure, in which case Ebuf is filled in with an appropriate error message. </dd></dl>

</div>
</div>
<a class="anchor" id="ga28ea5971235f478c0bd3bd2ce1c63a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapRead </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PBYTE&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>BufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&#160;</td>
          <td class="paramname"><em>PReceievedBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname"><a class="el" href="structBuffer.html">Buffer</a></td><td>pointer to the buffer that will be filled with captured packets. </td></tr>
    <tr><td class="paramname">BufSize</td><td>size of the input buffer that will contain the packets, in bytes. </td></tr>
    <tr><td class="paramname">PReceievedBytes</td><td>Pointer to a user supplied variable that will receive the number of bytes copied by AirpcapRead. Can be smaller than BufSize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>802.11 frames are returned by the driver in buffers. Every 802.11 frame in the buffer is preceded by a <a class="el" href="group__airpcapdefs.html#ga595a576fc245c805a444cfd20d65a2af">AirpcapBpfHeader</a> structure. The suggested way to use an AirPcap adapter is through the pcap API exported by wpcap.dll. If this is not possible, the Capture_radio and Capture_no_radio examples in the AirPcap developer's pack show how to properly decode the packets in the read buffer returned by <a class="el" href="group__airpcapfuncs.html#ga28ea5971235f478c0bd3bd2ce1c63a10" title="Fills a user-provided buffer with zero or more packets that have been captured on the referenced adap...">AirpcapRead()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>this function is NOT blocking. Blocking behavior can be obtained using the event returned by <a class="el" href="group__airpcapfuncs.html#ga3bb1ee017987102c70ea7da012e67559">AirpcapGetReadEvent()</a>. See also <a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga205739adab5b532ba07d342636a6506c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDecryptionState </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga1524eaffea4a4ff173bf52c9da577fb8">AirpcapDecryptionState</a>&#160;</td>
          <td class="paramname"><em>Enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">Enable</td><td>Either <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a> or <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a5cdd06a36410cf0163d5621adcf39512">AIRPCAP_DECRYPTION_OFF</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>The adapter-specific decryption keys can be configured with the <a class="el" href="group__airpcapfuncs.html#ga12a13dcb21b6afe5f9eb3497864a0eb1">AirpcapSetDeviceKeys()</a> function. </p>
<dl class="section note"><dt>Note</dt><dd>By default, the driver is configured with <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c4803da4b6f886e8f8bb5bd4ee89d03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDeviceChannel </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">Channel</td><td>the new channel to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>The list of available channels can be retrieved with <a class="el" href="group__airpcapfuncs.html#ga9b94f343249d70d598e4b0db5c6561c1">AirpcapGetDeviceSupportedChannels()</a>. The default channel setting is 6.</p>
<dl class="section note"><dt>Note</dt><dd>this is a device-related function: when you change the channel from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0677e7ff539c4a0bb1154e2710bb371f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDeviceChannelEx </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga602d987914eb1db696ab8a7fada8f12b">AirpcapChannelInfo</a>&#160;</td>
          <td class="paramname"><em>ChannelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">ChannelInfo</td><td>The new channel information to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this is a device-related function: when you change the channel from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga12a13dcb21b6afe5f9eb3497864a0eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDeviceKeys </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a>&#160;</td>
          <td class="paramname"><em>KeysCollection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle an open adapter instance. </td></tr>
    <tr><td class="paramname">KeysCollection</td><td>Pointer to a PAirpcapKeysCollection structure that contains the keys to be set in the driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation is successful. FALSE otherwise.</dd></dl>
<p>The AirPcap driver is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames to the application.</p>
<p>This function allows to set the <b>adapter-specific</b> set of keys. These keys will be used by the specified adapter only, and will not be used by other airpcap devices besides the specified one.</p>
<p>At this time, the only supported decryption method is WEP.</p>
<p>The keys are applied to the packets in the same order they appear in the KeysCollection structure until the packet is correctly decrypted, therefore putting frequently used keys at the beginning of the structure improves performance.</p>
<dl class="section note"><dt>Note</dt><dd>: when you change the set of keys from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73f354cc8ec91e5715d30d2b2b343528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDriverDecryptionState </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga1524eaffea4a4ff173bf52c9da577fb8">AirpcapDecryptionState</a>&#160;</td>
          <td class="paramname"><em>Enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">Enable</td><td>Either <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a> or <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a5cdd06a36410cf0163d5621adcf39512">AIRPCAP_DECRYPTION_OFF</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>The global decryption keys can be configured with the <a class="el" href="group__airpcapfuncs.html#gab4bbee0e89e2ec706c680148f1163d4d">AirpcapSetDriverKeys()</a> function. </p>
<dl class="section note"><dt>Note</dt><dd>By default, the driver is configured with <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab4bbee0e89e2ec706c680148f1163d4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDriverKeys </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a>&#160;</td>
          <td class="paramname"><em>KeysCollection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle an open adapter instance. </td></tr>
    <tr><td class="paramname">KeysCollection</td><td>Pointer to a PAirpcapKeysCollection structure that contains the keys to be set in the driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation is successful. FALSE otherwise.</dd></dl>
<p>The AirPcap driver is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames to the application.</p>
<p>This function allows to set the <b>global driver</b> set of keys. These keys will be used by all the adapters plugged in the machine.</p>
<p>At this time, the only supported decryption method is WEP.</p>
<p>The keys are applied to the packets in the same order they appear in the KeysCollection structure until the packet is correctly decrypted, therefore putting frequently used keys at the beginning of the structure improves performance.</p>
<dl class="section note"><dt>Note</dt><dd>: when you change the set of keys from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14cc811fb136709135e5fc7de26d2096"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetFcsPresence </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>IsFcsPresent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">IsFcsPresent</td><td>TRUE if the packets should include the FCS. FALSE otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>In the default configuration, the adapter includes the FCS in the captured packets. The MAC Frame Check Sequence is 4 bytes and is located at the end of the 802.11 packet, with both AIRPCAP_LT_802_11 and AIRPCAP_LT_802_11_PLUS_RADIO link types. When the FCS inclusion is turned on, and if the link type is AIRPCAP_LT_802_11_PLUS_RADIO, the radiotap header that precedes each frame has two additional fields at the end: Padding and FCS. These two fields are not present when FCS inclusion is off. </p>

</div>
</div>
<a class="anchor" id="gae17c18f94e959905de419a7f065829fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetFcsValidation </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga9a5d9c63fb74f8adf053b2851f1e3aac">AirpcapValidationType</a>&#160;</td>
          <td class="paramname"><em>ValidationType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">ValidationType</td><td>The type of validation the driver will perform. See the documentation of <a class="el" href="group__airpcapdefs.html#ga9a5d9c63fb74f8adf053b2851f1e3aac">AirpcapValidationType</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>By default, the driver is configured in <a class="el" href="group__airpcapdefs.html#gga055511accfcb2816fce9782d9b57ad50a4c6ecd77d205c51cf150189e5358ec95">AIRPCAP_VT_ACCEPT_EVERYTHING</a> mode. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae7f10fcd12b5263dc4af0ec83db03cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetFilter </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVOID&#160;</td>
          <td class="paramname"><em>Instructions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>Len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">Instructions</td><td>pointer to the first BPF instruction in the array. Corresponds to the bf_insns in a bpf_program structure (see the WinPcap documentation at <a href="http://www.winpcap.org/devel.htm">http://www.winpcap.org/devel.htm</a>). </td></tr>
    <tr><td class="paramname">Len</td><td>Number of instructions in the array pointed by the previous field. Corresponds to the bf_len in a a bpf_program structure (see the WinPcap documentation at <a href="http://www.winpcap.org/devel.htm">http://www.winpcap.org/devel.htm</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>The AirPcap driver is able to perform kernel-level filtering using the standard BPF pseudo-machine format. You can read the WinPcap documentation at <a href="http://www.winpcap.org/devel.htm">http://www.winpcap.org/devel.htm</a> for more details on the BPF filtering mechaism.</p>
<p>A filter can be automatically created by using the pcap_compile() function of the WinPcap API. This function converts a human readable text expression with the tcpdump/libpcap syntax into a BPF program. If your program doesn't link wpcap, but you need to generate the code for a particular filter, you can run WinDump with the -d or -dd or -ddd flags to obtain the pseudocode. </p>

</div>
</div>
<a class="anchor" id="gae09c4d22f8bc55b4c3410e55b6d26395"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetKernelBuffer </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>BufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>New size, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>Every AirPcap open instance has an associated kernel buffer, whose default size is 1 Mbyte. This function can be used to change the size of this buffer, and can be called at any time. A bigger kernel buffer size decreases the risk of dropping packets during network bursts or when the application is busy, at the cost of higher kernel memory usage.</p>
<dl class="section note"><dt>Note</dt><dd>don't use this function unless you know what you are doing. Due to caching issues and bigger non-paged memory consumption, bigger buffer sizes can decrease the capture performace instead of improving it. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1adedd10e4f67674277dcab81fe0fd14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetLinkType </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga141f7efbb58f0a6a71a77721624e70b1">AirpcapLinkType</a>&#160;</td>
          <td class="paramname"><em>NewLinkType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">NewLinkType</td><td>the "link type", i.e. the format of the frames that will be received from the adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>the "link type" determines how the driver will encode the packets captured from the network. Aircap supports two link types:</p>
<ul>
<li><a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932caccca07b1bce56bf355be0d773dc0a777">AIRPCAP_LT_802_11</a>, to capture 802.11 frames (including control frames) without any power information. Look at the Capture_no_radio example application in the developer's pack for a reference on how to decode 802.11 frames with this link type.</li>
<li><a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca8c943a33948170293e062a185dba443e">AIRPCAP_LT_802_11_PLUS_RADIO</a>, to capture 802.11 frames (including control frames) with a radiotap header that contains power and channel information. More information about the radiotap header can be found in the radiotap section. Moreover, the "Capture_radio" example application in the developer's pack can be used as a reference on how to decode 802.11 frames with radiotap headers.</li>
<li><a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca185676c98d51f262ed0b21f0abc11753">AIRPCAP_LT_802_11_PLUS_PPI</a>, to capture 802.11 frames (including control frames) with a Per Packet Information (PPI) header that contains per-packet meta information like channel and power information. More details on the PPI header can be founf in the PPI online documentation (TODO). </li>
</ul>

</div>
</div>
<a class="anchor" id="ga276dc280fc36d07e40519a8606383f86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetMinToCopy </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>MinToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">MinToCopy</td><td>is the mintocopy size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>When the number of bytes in the kernel buffer changes from less than mintocopy bytes to greater than or equal to mintocopy bytes, the read event is signalled (see <a class="el" href="group__airpcapfuncs.html#ga3bb1ee017987102c70ea7da012e67559">AirpcapGetReadEvent()</a>). A high value for mintocopy results in poor responsiveness since the driver may signal the application "long" after the arrival of the packet. And a high value results in low CPU loading by minimizing the number of user/kernel context switches. A low MinToCopy results in good responsiveness since the driver will signal the application close to the arrival time of the packet. This has higher CPU loading over the first approach. </p>

</div>
</div>
<a class="anchor" id="gab7db92c5b0267f46400e7127dc8314ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetMonitorMode </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>MonitorModeEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">MonitorModeEnabled</td><td>If TRUE, the adapter will be put in monitor mode. If FALSE, the adapter will be configured for normal operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>When monitor mode is on, the adapter captures all the packets transmitted on the channel. This includes:</p>
<ul>
<li>unicast packets</li>
<li>multicast packets</li>
<li>broadcast packets</li>
<li>control and management packets</li>
</ul>
<p>When monitor mode is off, the adapter has a filter on unicast packets to capture only the packets whose MAC destination address equals to the adapter's address. This means the following frames will be received:</p>
<ul>
<li>unicast packets with the address of the adapter</li>
<li>multicast packets</li>
<li>broadcast packets</li>
<li>beacons and probe requests</li>
</ul>
<p>The main reason to turn monitor mode off is that, when not in monitor mode, the adapter will acknowledge the data frames sent to its address. This is useful when the adapter needs to interact with other devices on the 802.11 network, bacause handling the ACKs in software is too slow.</p>
<dl class="section note"><dt>Note</dt><dd>When an adapter is plugged into the system, it's always configured with monitor mode ON. The monitor mode configuration is not stored persistently, so if you want to turn monitor mode off, you will need to do it every time you open the adapter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga591ddeab1e4c8883e18d127724d1d041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapStoreCurConfigAsAdapterDefault </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success. FALSE on failure.</dd></dl>
<p>Almost all the AirPcap calls that modify the configuration (<a class="el" href="group__airpcapfuncs.html#ga1adedd10e4f67674277dcab81fe0fd14">AirpcapSetLinkType()</a>, <a class="el" href="group__airpcapfuncs.html#ga14cc811fb136709135e5fc7de26d2096">AirpcapSetFcsPresence()</a>, <a class="el" href="group__airpcapfuncs.html#gae17c18f94e959905de419a7f065829fd">AirpcapSetFcsValidation()</a>, <a class="el" href="group__airpcapfuncs.html#gae09c4d22f8bc55b4c3410e55b6d26395">AirpcapSetKernelBuffer()</a>, <a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy()</a>) affect only the referenced AirPcap open instance. This means that if you do another <a class="el" href="group__airpcapfuncs.html#ga69a24296462970dd8915aae1039b2bb3">AirpcapOpen()</a> on the same adapter, the configuration changes will not be remembered, and the new adapter handle will have default configuration settings.</p>
<p>Exceptions to this rule are the <a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel()</a> and <a class="el" href="group__airpcapfuncs.html#ga12a13dcb21b6afe5f9eb3497864a0eb1">AirpcapSetDeviceKeys()</a> functions: a channel change is reflected on all the open instances, and remembered until the next call to <a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel()</a>, until the adapter is unplugged, or until the machine is powered off. Same thing for the configuration of the WEP keys.</p>
<p><a class="el" href="group__airpcapfuncs.html#ga591ddeab1e4c8883e18d127724d1d041" title="Saves the configuration of the specified adapter in the registry, so that it becomes the default for ...">AirpcapStoreCurConfigAsAdapterDefault()</a> stores the configuration of the give open instance as the default for the adapter: all the instances opened in the future will have the same configuration that this adapter currently has. The configuration is stored in the registry, therefore it is remembered even when the adapter is unplugged or the machine is turned off. However, an adapter doesn't bring its configuration with it from machine to machine.</p>
<p>the configuration information saved in the registry includes the following parameters:</p>
<ul>
<li>channel</li>
<li>kernel buffer size</li>
<li>mintocopy</li>
<li>link type</li>
<li>CRC presence</li>
<li>Encryption keys</li>
<li>Encryption Enabled/Disabled state</li>
</ul>
<p>The configuration is adapter-specific. This means that changing the configuration of an adapter doesn't modify the one of the other adapters that are currently used or that will be used in the future.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__airpcapfuncs.html#ga591ddeab1e4c8883e18d127724d1d041" title="Saves the configuration of the specified adapter in the registry, so that it becomes the default for ...">AirpcapStoreCurConfigAsAdapterDefault()</a> must have exclusive access to the adapter &ndash; it will fail if more than one AirPcap handle is opened at the same time for this adapter. <a class="el" href="group__airpcapfuncs.html#ga591ddeab1e4c8883e18d127724d1d041" title="Saves the configuration of the specified adapter in the registry, so that it becomes the default for ...">AirpcapStoreCurConfigAsAdapterDefault()</a> needs administrator privileges. It will fail if the calling user is not a local machine administrator. </dd></dl>

</div>
</div>
<a class="anchor" id="gafb0fe78ab2fa519d66aca8b22f6cad49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapTurnLedOff </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>LedNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">LedNumber</td><td>zero-based identifier of the LED to turn off. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf225a0632d8e077ef431ae994b8b16f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapTurnLedOn </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>LedNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">LedNumber</td><td>zero-based identifier of the LED to turn on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga70134a6b7dddf5b6227740474c0d1b95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapWrite </td>
          <td>(</td>
          <td class="paramtype">PAirpcapHandle&#160;</td>
          <td class="paramname"><em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PCHAR&#160;</td>
          <td class="paramname"><em>TxPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>PacketLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdapterHandle</td><td>Handle to the adapter. </td></tr>
    <tr><td class="paramname">TxPacket</td><td>Pointer to a buffer that contains the packet to be transmitted. </td></tr>
    <tr><td class="paramname">PacketLen</td><td>Length of the buffer pointed by the TxPacket argument, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success.</dd></dl>
<p>The packet will be transmitted on the channel the device is currently set. To change the device adapter, use the <a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel()</a> function.</p>
<p>If the linktype of the adapter is AIRPCAP_LT_802_11, the buffer pointed by TxPacket should contain just the 802.11 packet, without additional information. The packet will be transmitted at 1Mbps.</p>
<p>If the linktype of the adapter is AIRPCAP_LT_802_11_PLUS_RADIO, the buffer pointed by TxPacket should contain a radiotap header followed by the 802.11 packet. AirpcapWrite will use the rate information in the radiotap header when transmitting the packet. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
