<html>
<head>
<title>r</title>
<meta name='robots' content='noindex,nofollow'>
<meta name='generator' content='GLOBAL-5.7.1'>
</head>
<body text='#191970' bgcolor='#f5f5dc' vlink='gray'>
<pre>
<a href='../S/21.html#L118'>r</a>                 118 cbench/oflops/wc_event.c 	int l,r;
<a href='../S/21.html#L124'>r</a>                 124 cbench/oflops/wc_event.c 	r = RIGHT(i);
<a href='../S/21.html#L128'>r</a>                 128 cbench/oflops/wc_event.c 	if((r&lt;= pq-&gt;size)&amp;&amp; (timercmp(&amp;pq-&gt;array[r].key,&amp;pq-&gt;array[largest].key,&lt;)))
<a href='../S/21.html#L129'>r</a>                 129 cbench/oflops/wc_event.c 		largest=r;
<a href='../S/314.html#L310'>r</a>                 310 cbench/openflow/datapath/linux-2.6/compat-2.6/include/linux/lockdep.h # define lock_acquire(l, s, t, r, c, i)		do { } while (0)
<a href='../S/851.html#L1267'>r</a>                1267 cbench/openflow/lib/netdev.c     struct arpreq r;
<a href='../S/851.html#L1271'>r</a>                1271 cbench/openflow/lib/netdev.c     memset(&amp;r, 0, sizeof r);
<a href='../S/851.html#L1272'>r</a>                1272 cbench/openflow/lib/netdev.c     pa = (struct sockaddr_in *) &amp;r.arp_pa;
<a href='../S/851.html#L1276'>r</a>                1276 cbench/openflow/lib/netdev.c     r.arp_ha.sa_family = ARPHRD_ETHER;
<a href='../S/851.html#L1277'>r</a>                1277 cbench/openflow/lib/netdev.c     r.arp_flags = 0;
<a href='../S/851.html#L1278'>r</a>                1278 cbench/openflow/lib/netdev.c     strncpy(r.arp_dev, netdev-&gt;name, sizeof r.arp_dev);
<a href='../S/851.html#L1279'>r</a>                1279 cbench/openflow/lib/netdev.c     retval = ioctl(af_inet_sock, SIOCGARP, &amp;r) &lt; 0 ? errno : 0;
<a href='../S/851.html#L1281'>r</a>                1281 cbench/openflow/lib/netdev.c         memcpy(mac, r.arp_ha.sa_data, ETH_ADDR_LEN);
<a href='../S/835.html#L87'>r</a>                  87 cbench/openflow/lib/socket-util.c         struct rlimit r;
<a href='../S/835.html#L88'>r</a>                  88 cbench/openflow/lib/socket-util.c         if (!getrlimit(RLIMIT_NOFILE, &amp;r)
<a href='../S/835.html#L89'>r</a>                  89 cbench/openflow/lib/socket-util.c             &amp;&amp; r.rlim_cur != RLIM_INFINITY
<a href='../S/835.html#L90'>r</a>                  90 cbench/openflow/lib/socket-util.c             &amp;&amp; r.rlim_cur != RLIM_SAVED_MAX
<a href='../S/835.html#L91'>r</a>                  91 cbench/openflow/lib/socket-util.c             &amp;&amp; r.rlim_cur != RLIM_SAVED_CUR) {
<a href='../S/835.html#L92'>r</a>                  92 cbench/openflow/lib/socket-util.c             max_fds = r.rlim_cur;
<a href='../S/842.html#L53'>r</a>                  53 cbench/openflow/lib/tag.c         uint16_t r = random_uint16();
<a href='../S/842.html#L54'>r</a>                  54 cbench/openflow/lib/tag.c         x = r &amp; (N_TAG_BITS - 1);
<a href='../S/842.html#L55'>r</a>                  55 cbench/openflow/lib/tag.c         y = r &gt;&gt; (16 - LOG2_N_TAG_BITS);
<a href='../S/789.html#L106'>r</a>                 106 cbench/openflow/secchan/fail-open.c fail_open_local_packet_cb(struct relay *r, void *fail_open_)
<a href='../S/789.html#L113'>r</a>                 113 cbench/openflow/secchan/fail-open.c                                r-&gt;halves[HALF_LOCAL].rxbuf);
<a href='../S/791.html#L140'>r</a>                 140 cbench/openflow/secchan/in-band.c in_band_local_packet_cb(struct relay *r, void *in_band_)
<a href='../S/791.html#L143'>r</a>                 143 cbench/openflow/secchan/in-band.c     struct rconn *rc = r-&gt;halves[HALF_LOCAL].rconn;
<a href='../S/791.html#L151'>r</a>                 151 cbench/openflow/secchan/in-band.c     if (!get_ofp_packet_eth_header(r, &amp;opi, &amp;eth) || !in_band-&gt;of_device) {
<a href='../S/810.html#L230'>r</a>                 230 cbench/openflow/secchan/port-watcher.c port_watcher_local_packet_cb(struct relay *r, void *pw_)
<a href='../S/810.html#L233'>r</a>                 233 cbench/openflow/secchan/port-watcher.c     struct ofpbuf *msg = r-&gt;halves[HALF_LOCAL].rxbuf;
<a href='../S/810.html#L312'>r</a>                 312 cbench/openflow/secchan/port-watcher.c port_watcher_remote_packet_cb(struct relay *r, void *pw_)
<a href='../S/810.html#L315'>r</a>                 315 cbench/openflow/secchan/port-watcher.c     struct ofpbuf *msg = r-&gt;halves[HALF_REMOTE].rxbuf;
<a href='../S/804.html#L152'>r</a>                 152 cbench/openflow/secchan/ratelimit.c rate_limit_local_packet_cb(struct relay *r, void *rl_)
<a href='../S/804.html#L158'>r</a>                 158 cbench/openflow/secchan/ratelimit.c     opi = get_ofp_packet_in(r);
<a href='../S/804.html#L177'>r</a>                 177 cbench/openflow/secchan/ratelimit.c         struct ofpbuf *msg = r-&gt;halves[HALF_LOCAL].rxbuf;
<a href='../S/801.html#L236'>r</a>                 236 cbench/openflow/secchan/secchan.c         struct relay *r, *n;
<a href='../S/801.html#L240'>r</a>                 240 cbench/openflow/secchan/secchan.c         LIST_FOR_EACH_SAFE (r, n, struct relay, node, &amp;relays) {
<a href='../S/801.html#L241'>r</a>                 241 cbench/openflow/secchan/secchan.c             relay_run(r, &amp;secchan);
<a href='../S/801.html#L245'>r</a>                 245 cbench/openflow/secchan/secchan.c                 struct relay *r = relay_accept(&amp;s, listeners[i]);
<a href='../S/801.html#L246'>r</a>                 246 cbench/openflow/secchan/secchan.c                 if (!r) {
<a href='../S/801.html#L249'>r</a>                 249 cbench/openflow/secchan/secchan.c                 list_push_back(&amp;relays, &amp;r-&gt;node);
<a href='../S/801.html#L280'>r</a>                 280 cbench/openflow/secchan/secchan.c         LIST_FOR_EACH (r, struct relay, node, &amp;relays) {
<a href='../S/801.html#L281'>r</a>                 281 cbench/openflow/secchan/secchan.c             relay_wait(r);
<a href='../S/801.html#L344'>r</a>                 344 cbench/openflow/secchan/secchan.c get_ofp_packet_in(struct relay *r)
<a href='../S/801.html#L346'>r</a>                 346 cbench/openflow/secchan/secchan.c     struct ofpbuf *msg = r-&gt;halves[HALF_LOCAL].rxbuf;
<a href='../S/801.html#L360'>r</a>                 360 cbench/openflow/secchan/secchan.c get_ofp_packet_eth_header(struct relay *r, struct ofp_packet_in **opip,
<a href='../S/801.html#L364'>r</a>                 364 cbench/openflow/secchan/secchan.c     struct ofp_packet_in *opi = get_ofp_packet_in(r);
<a href='../S/801.html#L436'>r</a>                 436 cbench/openflow/secchan/secchan.c     struct relay *r = xcalloc(1, sizeof *r);
<a href='../S/801.html#L437'>r</a>                 437 cbench/openflow/secchan/secchan.c     r-&gt;halves[HALF_LOCAL].rconn = local;
<a href='../S/801.html#L438'>r</a>                 438 cbench/openflow/secchan/secchan.c     r-&gt;halves[HALF_REMOTE].rconn = remote;
<a href='../S/801.html#L439'>r</a>                 439 cbench/openflow/secchan/secchan.c     r-&gt;is_mgmt_conn = is_mgmt_conn;
<a href='../S/801.html#L440'>r</a>                 440 cbench/openflow/secchan/secchan.c     r-&gt;async_rconn = async;
<a href='../S/801.html#L441'>r</a>                 441 cbench/openflow/secchan/secchan.c     return r;
<a href='../S/801.html#L445'>r</a>                 445 cbench/openflow/secchan/secchan.c call_local_packet_cbs(struct secchan *secchan, struct relay *r)
<a href='../S/801.html#L450'>r</a>                 450 cbench/openflow/secchan/secchan.c         if (cb &amp;&amp; (cb)(r, h-&gt;aux)) {
<a href='../S/801.html#L458'>r</a>                 458 cbench/openflow/secchan/secchan.c call_remote_packet_cbs(struct secchan *secchan, struct relay *r)
<a href='../S/801.html#L463'>r</a>                 463 cbench/openflow/secchan/secchan.c         if (cb &amp;&amp; (cb)(r, h-&gt;aux)) {
<a href='../S/801.html#L471'>r</a>                 471 cbench/openflow/secchan/secchan.c relay_run(struct relay *r, struct secchan *secchan)
<a href='../S/801.html#L476'>r</a>                 476 cbench/openflow/secchan/secchan.c     if (r-&gt;async_rconn) {
<a href='../S/801.html#L477'>r</a>                 477 cbench/openflow/secchan/secchan.c         rconn_run(r-&gt;async_rconn);
<a href='../S/801.html#L480'>r</a>                 480 cbench/openflow/secchan/secchan.c         rconn_run(r-&gt;halves[i].rconn);
<a href='../S/801.html#L487'>r</a>                 487 cbench/openflow/secchan/secchan.c             struct half *this = &amp;r-&gt;halves[i];
<a href='../S/801.html#L488'>r</a>                 488 cbench/openflow/secchan/secchan.c             struct half *peer = &amp;r-&gt;halves[!i];
<a href='../S/801.html#L492'>r</a>                 492 cbench/openflow/secchan/secchan.c                 if (!this-&gt;rxbuf &amp;&amp; i == HALF_LOCAL &amp;&amp; r-&gt;async_rconn) {
<a href='../S/801.html#L493'>r</a>                 493 cbench/openflow/secchan/secchan.c                     this-&gt;rxbuf = rconn_recv(r-&gt;async_rconn);
<a href='../S/801.html#L495'>r</a>                 495 cbench/openflow/secchan/secchan.c                 if (this-&gt;rxbuf &amp;&amp; (i == HALF_REMOTE || !r-&gt;is_mgmt_conn)) {
<a href='../S/801.html#L497'>r</a>                 497 cbench/openflow/secchan/secchan.c                         ? call_local_packet_cbs(secchan, r)
<a href='../S/801.html#L498'>r</a>                 498 cbench/openflow/secchan/secchan.c                         : call_remote_packet_cbs(secchan, r))
<a href='../S/801.html#L526'>r</a>                 526 cbench/openflow/secchan/secchan.c     if (r-&gt;is_mgmt_conn) {
<a href='../S/801.html#L528'>r</a>                 528 cbench/openflow/secchan/secchan.c             struct half *this = &amp;r-&gt;halves[i];
<a href='../S/801.html#L530'>r</a>                 530 cbench/openflow/secchan/secchan.c                 relay_destroy(r);
<a href='../S/801.html#L538'>r</a>                 538 cbench/openflow/secchan/secchan.c relay_wait(struct relay *r)
<a href='../S/801.html#L542'>r</a>                 542 cbench/openflow/secchan/secchan.c     if (r-&gt;async_rconn) {
<a href='../S/801.html#L543'>r</a>                 543 cbench/openflow/secchan/secchan.c         rconn_run_wait(r-&gt;async_rconn);
<a href='../S/801.html#L546'>r</a>                 546 cbench/openflow/secchan/secchan.c         struct half *this = &amp;r-&gt;halves[i];
<a href='../S/801.html#L551'>r</a>                 551 cbench/openflow/secchan/secchan.c             if (i == HALF_LOCAL &amp;&amp; r-&gt;async_rconn) {
<a href='../S/801.html#L552'>r</a>                 552 cbench/openflow/secchan/secchan.c                 rconn_recv_wait(r-&gt;async_rconn);
<a href='../S/801.html#L559'>r</a>                 559 cbench/openflow/secchan/secchan.c relay_destroy(struct relay *r)
<a href='../S/801.html#L563'>r</a>                 563 cbench/openflow/secchan/secchan.c     list_remove(&amp;r-&gt;node);
<a href='../S/801.html#L564'>r</a>                 564 cbench/openflow/secchan/secchan.c     rconn_destroy(r-&gt;async_rconn);
<a href='../S/801.html#L566'>r</a>                 566 cbench/openflow/secchan/secchan.c         struct half *this = &amp;r-&gt;halves[i];
<a href='../S/801.html#L570'>r</a>                 570 cbench/openflow/secchan/secchan.c     free(r);
<a href='../S/805.html#L71'>r</a>                  71 cbench/openflow/secchan/status.c switch_status_remote_packet_cb(struct relay *r, void *ss_)
<a href='../S/805.html#L74'>r</a>                  74 cbench/openflow/secchan/status.c     struct rconn *rc = r-&gt;halves[HALF_REMOTE].rconn;
<a href='../S/805.html#L75'>r</a>                  75 cbench/openflow/secchan/status.c     struct ofpbuf *msg = r-&gt;halves[HALF_REMOTE].rxbuf;
<a href='../S/797.html#L64'>r</a>                  64 cbench/openflow/secchan/stp-secchan.c stp_local_packet_cb(struct relay *r, void *stp_)
<a href='../S/797.html#L66'>r</a>                  66 cbench/openflow/secchan/stp-secchan.c     struct ofpbuf *msg = r-&gt;halves[HALF_LOCAL].rxbuf;
<a href='../S/797.html#L84'>r</a>                  84 cbench/openflow/secchan/stp-secchan.c     if (!get_ofp_packet_eth_header(r, &amp;opi, &amp;eth)
<a href='../S/204.html#L532'>r</a>                 532 cbench/openflow/udatapath/datapath.c     struct remote *r, *rn;
<a href='../S/204.html#L595'>r</a>                 595 cbench/openflow/udatapath/datapath.c     LIST_FOR_EACH_SAFE (r, rn, struct remote, node, &amp;dp-&gt;remotes) {
<a href='../S/204.html#L596'>r</a>                 596 cbench/openflow/udatapath/datapath.c         remote_run(dp, r);
<a href='../S/204.html#L615'>r</a>                 615 cbench/openflow/udatapath/datapath.c remote_run(struct datapath *dp, struct remote *r)
<a href='../S/204.html#L619'>r</a>                 619 cbench/openflow/udatapath/datapath.c     rconn_run(r-&gt;rconn);
<a href='../S/204.html#L624'>r</a>                 624 cbench/openflow/udatapath/datapath.c         if (!r-&gt;cb_dump) {
<a href='../S/204.html#L628'>r</a>                 628 cbench/openflow/udatapath/datapath.c             buffer = rconn_recv(r-&gt;rconn);
<a href='../S/204.html#L637'>r</a>                 637 cbench/openflow/udatapath/datapath.c                 sender.remote = r;
<a href='../S/204.html#L645'>r</a>                 645 cbench/openflow/udatapath/datapath.c             if (r-&gt;n_txq &lt; TXQ_LIMIT) {
<a href='../S/204.html#L646'>r</a>                 646 cbench/openflow/udatapath/datapath.c                 int error = r-&gt;cb_dump(dp, r-&gt;cb_aux);
<a href='../S/204.html#L652'>r</a>                 652 cbench/openflow/udatapath/datapath.c                     r-&gt;cb_done(r-&gt;cb_aux);
<a href='../S/204.html#L653'>r</a>                 653 cbench/openflow/udatapath/datapath.c                     r-&gt;cb_dump = NULL;
<a href='../S/204.html#L661'>r</a>                 661 cbench/openflow/udatapath/datapath.c     if (!rconn_is_alive(r-&gt;rconn)) {
<a href='../S/204.html#L662'>r</a>                 662 cbench/openflow/udatapath/datapath.c         remote_destroy(r);
<a href='../S/204.html#L667'>r</a>                 667 cbench/openflow/udatapath/datapath.c remote_wait(struct remote *r)
<a href='../S/204.html#L669'>r</a>                 669 cbench/openflow/udatapath/datapath.c     rconn_run_wait(r-&gt;rconn);
<a href='../S/204.html#L670'>r</a>                 670 cbench/openflow/udatapath/datapath.c     rconn_recv_wait(r-&gt;rconn);
<a href='../S/204.html#L674'>r</a>                 674 cbench/openflow/udatapath/datapath.c remote_destroy(struct remote *r)
<a href='../S/204.html#L676'>r</a>                 676 cbench/openflow/udatapath/datapath.c     if (r) {
<a href='../S/204.html#L677'>r</a>                 677 cbench/openflow/udatapath/datapath.c         if (r-&gt;cb_dump &amp;&amp; r-&gt;cb_done) {
<a href='../S/204.html#L678'>r</a>                 678 cbench/openflow/udatapath/datapath.c             r-&gt;cb_done(r-&gt;cb_aux);
<a href='../S/204.html#L680'>r</a>                 680 cbench/openflow/udatapath/datapath.c         list_remove(&amp;r-&gt;node);
<a href='../S/204.html#L681'>r</a>                 681 cbench/openflow/udatapath/datapath.c         rconn_destroy(r-&gt;rconn);
<a href='../S/204.html#L682'>r</a>                 682 cbench/openflow/udatapath/datapath.c         free(r);
<a href='../S/204.html#L727'>r</a>                 727 cbench/openflow/udatapath/datapath.c     struct remote *r;
<a href='../S/204.html#L736'>r</a>                 736 cbench/openflow/udatapath/datapath.c     LIST_FOR_EACH (r, struct remote, node, &amp;dp-&gt;remotes) {
<a href='../S/204.html#L737'>r</a>                 737 cbench/openflow/udatapath/datapath.c         remote_wait(r);
<a href='../S/204.html#L924'>r</a>                 924 cbench/openflow/udatapath/datapath.c         struct remote *r, *prev = NULL;
<a href='../S/204.html#L925'>r</a>                 925 cbench/openflow/udatapath/datapath.c         LIST_FOR_EACH (r, struct remote, node, &amp;dp-&gt;remotes) {
<a href='../S/204.html#L929'>r</a>                 929 cbench/openflow/udatapath/datapath.c             prev = r;
<a href='../S/405.html#L107'>r</a>                 107 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/wslua/wslua.h 	range_t *r;
<a href='../S/1090.html#L889'>r</a>                 889 libraries/libcli/libcli.c     int r;
<a href='../S/1090.html#L910'>r</a>                 910 libraries/libcli/libcli.c         r = cli_find_command(cli, cli-&gt;commands, num_words, words, 0, filters);
<a href='../S/1090.html#L912'>r</a>                 912 libraries/libcli/libcli.c         r = CLI_ERROR;
<a href='../S/1090.html#L917'>r</a>                 917 libraries/libcli/libcli.c     if (r == CLI_QUIT)
<a href='../S/1090.html#L918'>r</a>                 918 libraries/libcli/libcli.c         return r;
<a href='../S/1090.html#L1141'>r</a>                1141 libraries/libcli/libcli.c             fd_set r;
<a href='../S/1090.html#L1178'>r</a>                1178 libraries/libcli/libcli.c             FD_ZERO(&amp;r);
<a href='../S/1090.html#L1179'>r</a>                1179 libraries/libcli/libcli.c             FD_SET(sockfd, &amp;r);
<a href='../S/1090.html#L1181'>r</a>                1181 libraries/libcli/libcli.c             if ((sr = select(sockfd + 1, &amp;r, NULL, NULL, &amp;tm)) &lt; 0)
<a href='../S/1090.html#L2051'>r</a>                2051 libraries/libcli/libcli.c     int r = CLI_ERROR;
<a href='../S/1090.html#L2067'>r</a>                2067 libraries/libcli/libcli.c             r = CLI_OK;
<a href='../S/1090.html#L2072'>r</a>                2072 libraries/libcli/libcli.c             r = CLI_OK;
<a href='../S/1090.html#L2077'>r</a>                2077 libraries/libcli/libcli.c         if (r == CLI_OK)
<a href='../S/1090.html#L2078'>r</a>                2078 libraries/libcli/libcli.c             r = CLI_ERROR;
<a href='../S/1090.html#L2080'>r</a>                2080 libraries/libcli/libcli.c             r = CLI_OK;
<a href='../S/1090.html#L2083'>r</a>                2083 libraries/libcli/libcli.c     return r;
<a href='../S/1090.html#L2137'>r</a>                2137 libraries/libcli/libcli.c     int r = CLI_ERROR;
<a href='../S/1090.html#L2152'>r</a>                2152 libraries/libcli/libcli.c         r = CLI_OK;
<a href='../S/1090.html#L2157'>r</a>                2157 libraries/libcli/libcli.c     return r;
</pre>
</body>
</html>
