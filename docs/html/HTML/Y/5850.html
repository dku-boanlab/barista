<html>
<head>
<title>pq</title>
<meta name='robots' content='noindex,nofollow'>
<meta name='generator' content='GLOBAL-5.7.1'>
</head>
<body text='#191970' bgcolor='#f5f5dc' vlink='gray'>
<pre>
<a href='../S/21.html#L54'>pq</a>                 54 cbench/oflops/wc_event.c static void heapify(wc_queue * pq, int i);
<a href='../S/21.html#L76'>pq</a>                 76 cbench/oflops/wc_event.c 	wc_queue *pq;
<a href='../S/21.html#L78'>pq</a>                 78 cbench/oflops/wc_event.c 	pq = malloc_and_check(sizeof(wc_queue));
<a href='../S/21.html#L79'>pq</a>                 79 cbench/oflops/wc_event.c 	if(pq==NULL){
<a href='../S/21.html#L83'>pq</a>                 83 cbench/oflops/wc_event.c 	pq-&gt;array = malloc_and_check(sizeof(qelm)*initSize);
<a href='../S/21.html#L84'>pq</a>                 84 cbench/oflops/wc_event.c 	if(pq-&gt;array == NULL){
<a href='../S/21.html#L86'>pq</a>                 86 cbench/oflops/wc_event.c         free(pq);
<a href='../S/21.html#L89'>pq</a>                 89 cbench/oflops/wc_event.c 	pq-&gt;size=0;
<a href='../S/21.html#L90'>pq</a>                 90 cbench/oflops/wc_event.c 	pq-&gt;length=initSize;
<a href='../S/21.html#L91'>pq</a>                 91 cbench/oflops/wc_event.c 	pq-&gt;timersEnabled=0;	// start with timers disabled
<a href='../S/21.html#L93'>pq</a>                 93 cbench/oflops/wc_event.c 	WC_Queue=pq;
<a href='../S/21.html#L94'>pq</a>                 94 cbench/oflops/wc_event.c 	return pq;
<a href='../S/21.html#L97'>pq</a>                 97 cbench/oflops/wc_event.c void wc_queue_free(/*@only@*/ wc_queue * pq){
<a href='../S/21.html#L98'>pq</a>                 98 cbench/oflops/wc_event.c 	assert(pq);
<a href='../S/21.html#L99'>pq</a>                 99 cbench/oflops/wc_event.c 	free(pq-&gt;array);
<a href='../S/21.html#L100'>pq</a>                100 cbench/oflops/wc_event.c 	free(pq);
<a href='../S/21.html#L104'>pq</a>                104 cbench/oflops/wc_event.c int wc_queue_isempty(wc_queue *pq){
<a href='../S/21.html#L105'>pq</a>                105 cbench/oflops/wc_event.c 	assert(pq);
<a href='../S/21.html#L106'>pq</a>                106 cbench/oflops/wc_event.c 	return (pq-&gt;size&lt;1);
<a href='../S/21.html#L117'>pq</a>                117 cbench/oflops/wc_event.c void heapify(wc_queue * pq, int i){
<a href='../S/21.html#L122'>pq</a>                122 cbench/oflops/wc_event.c 	assert(pq);
<a href='../S/21.html#L125'>pq</a>                125 cbench/oflops/wc_event.c 	if((l&lt;= pq-&gt;size)&amp;&amp; (timercmp(&amp;pq-&gt;array[l].key,&amp;pq-&gt;array[i].key,&lt;)))
<a href='../S/21.html#L128'>pq</a>                128 cbench/oflops/wc_event.c 	if((r&lt;= pq-&gt;size)&amp;&amp; (timercmp(&amp;pq-&gt;array[r].key,&amp;pq-&gt;array[largest].key,&lt;)))
<a href='../S/21.html#L132'>pq</a>                132 cbench/oflops/wc_event.c 		tmp=pq-&gt;array[i];
<a href='../S/21.html#L133'>pq</a>                133 cbench/oflops/wc_event.c 		pq-&gt;array[i]=pq-&gt;array[largest];
<a href='../S/21.html#L134'>pq</a>                134 cbench/oflops/wc_event.c 		pq-&gt;array[largest]=tmp;
<a href='../S/21.html#L135'>pq</a>                135 cbench/oflops/wc_event.c 		heapify(pq,largest);
<a href='../S/21.html#L140'>pq</a>                140 cbench/oflops/wc_event.c int wc_event_add(wc_queue* pq, void (*fun)(void *), void *arg, struct timeval key){
<a href='../S/21.html#L145'>pq</a>                145 cbench/oflops/wc_event.c 	assert(pq-&gt;timersEnabled==0);		// only allow adds when timers are off
<a href='../S/21.html#L146'>pq</a>                146 cbench/oflops/wc_event.c 	if((pq-&gt;size+1)&gt;=pq-&gt;length)		// the "+1" is critical, b/c we start at array[1]
<a href='../S/21.html#L147'>pq</a>                147 cbench/oflops/wc_event.c 		wc_queue_double(pq);
<a href='../S/21.html#L148'>pq</a>                148 cbench/oflops/wc_event.c 	pq-&gt;size++;
<a href='../S/21.html#L149'>pq</a>                149 cbench/oflops/wc_event.c 	i=pq-&gt;size;
<a href='../S/21.html#L155'>pq</a>                155 cbench/oflops/wc_event.c 	while((i&gt;1)&amp;&amp;(timercmp(&amp;pq-&gt;array[PARENT(i)].key,&amp;key,&gt;))){	// search heap
<a href='../S/21.html#L156'>pq</a>                156 cbench/oflops/wc_event.c 		pq-&gt;array[i]=pq-&gt;array[PARENT(i)];	// copy the parent's data down one level
<a href='../S/21.html#L159'>pq</a>                159 cbench/oflops/wc_event.c 	pq-&gt;array[i].key=key;
<a href='../S/21.html#L160'>pq</a>                160 cbench/oflops/wc_event.c 	pq-&gt;array[i].data=data;
<a href='../S/21.html#L161'>pq</a>                161 cbench/oflops/wc_event.c 	id=pq-&gt;array[i].id=WC_EVENT_ID++;
<a href='../S/21.html#L167'>pq</a>                167 cbench/oflops/wc_event.c static void wc_schedule_next_event(wc_queue *pq)
<a href='../S/21.html#L172'>pq</a>                172 cbench/oflops/wc_event.c 	assert(pq-&gt;timersEnabled);	// should only be called when timers are enabled
<a href='../S/21.html#L173'>pq</a>                173 cbench/oflops/wc_event.c 	assert(pq-&gt;size&gt;0);
<a href='../S/21.html#L177'>pq</a>                177 cbench/oflops/wc_event.c 	while(!wc_queue_isempty(pq))		
<a href='../S/21.html#L180'>pq</a>                180 cbench/oflops/wc_event.c 		data=&amp;pq-&gt;array[1];		// DUMBASS: we skip array[0] b/c it makes the math easier
<a href='../S/21.html#L185'>pq</a>                185 cbench/oflops/wc_event.c 			wc_run_next_event(pq);
<a href='../S/21.html#L192'>pq</a>                192 cbench/oflops/wc_event.c 	if(wc_queue_isempty(pq))
<a href='../S/21.html#L206'>pq</a>                206 cbench/oflops/wc_event.c int wc_queue_extract(wc_queue *pq , int * id, struct timeval * key,void (**fun)(void *), void **arg) {
<a href='../S/21.html#L208'>pq</a>                208 cbench/oflops/wc_event.c 	assert(pq);
<a href='../S/21.html#L209'>pq</a>                209 cbench/oflops/wc_event.c 	assert(pq-&gt;timersEnabled==0);
<a href='../S/21.html#L210'>pq</a>                210 cbench/oflops/wc_event.c 	if(pq-&gt;size&lt;1){		//empty
<a href='../S/21.html#L213'>pq</a>                213 cbench/oflops/wc_event.c 	data=pq-&gt;array[1].data;
<a href='../S/21.html#L214'>pq</a>                214 cbench/oflops/wc_event.c 	*key=pq-&gt;array[1].key;
<a href='../S/21.html#L215'>pq</a>                215 cbench/oflops/wc_event.c 	*id=pq-&gt;array[1].id;
<a href='../S/21.html#L216'>pq</a>                216 cbench/oflops/wc_event.c 	pq-&gt;array[1]=pq-&gt;array[pq-&gt;size];	// move first elm to end
<a href='../S/21.html#L217'>pq</a>                217 cbench/oflops/wc_event.c 	pq-&gt;size--;
<a href='../S/21.html#L218'>pq</a>                218 cbench/oflops/wc_event.c 	heapify(pq,1);
<a href='../S/21.html#L234'>pq</a>                234 cbench/oflops/wc_event.c int wc_event_remove(wc_queue * pq, int id,void (**fun)(void *),void **arg)
<a href='../S/21.html#L238'>pq</a>                238 cbench/oflops/wc_event.c 	assert(pq-&gt;timersEnabled==0);
<a href='../S/21.html#L239'>pq</a>                239 cbench/oflops/wc_event.c 	for(i=1;i&lt;=pq-&gt;size;i++)
<a href='../S/21.html#L240'>pq</a>                240 cbench/oflops/wc_event.c 		if(pq-&gt;array[i].id==id)
<a href='../S/21.html#L242'>pq</a>                242 cbench/oflops/wc_event.c 	if(i&gt;pq-&gt;size)
<a href='../S/21.html#L245'>pq</a>                245 cbench/oflops/wc_event.c 	verify_heap(pq);
<a href='../S/21.html#L247'>pq</a>                247 cbench/oflops/wc_event.c 	data = pq-&gt;array[i].data;
<a href='../S/21.html#L251'>pq</a>                251 cbench/oflops/wc_event.c 	pq-&gt;array[i]=pq-&gt;array[pq-&gt;size];
<a href='../S/21.html#L252'>pq</a>                252 cbench/oflops/wc_event.c 	pq-&gt;size--;
<a href='../S/21.html#L255'>pq</a>                255 cbench/oflops/wc_event.c 		heapify(pq,i);		// this is a log(log(n)) op, 
<a href='../S/21.html#L259'>pq</a>                259 cbench/oflops/wc_event.c 	verify_heap(pq);
<a href='../S/21.html#L271'>pq</a>                271 cbench/oflops/wc_event.c int wc_run_next_event(wc_queue * pq)
<a href='../S/21.html#L281'>pq</a>                281 cbench/oflops/wc_event.c 	if(wc_queue_isempty(pq))
<a href='../S/21.html#L283'>pq</a>                283 cbench/oflops/wc_event.c 	wc_queue_extract(pq,&amp;id,&amp;key,&amp;fun,&amp;arg);	// get event off top of heap
<a href='../S/21.html#L314'>pq</a>                314 cbench/oflops/wc_event.c int wc_get_next_event_delta(struct wc_queue * pq, struct timeval *delta)
<a href='../S/21.html#L318'>pq</a>                318 cbench/oflops/wc_event.c 	assert(pq-&gt;timersEnabled==0);	// should only be called when timers are disabled
<a href='../S/21.html#L319'>pq</a>                319 cbench/oflops/wc_event.c 	if(wc_queue_isempty(pq))
<a href='../S/21.html#L321'>pq</a>                321 cbench/oflops/wc_event.c 	data=&amp;pq-&gt;array[1];		// DUMBASS: we skip array[0] b/c it makes the math easier
<a href='../S/21.html#L340'>pq</a>                340 cbench/oflops/wc_event.c 	wc_queue *pq=WC_Queue;		// HACK; how do we pass state to a signal handler?; need to use globalvar
<a href='../S/21.html#L342'>pq</a>                342 cbench/oflops/wc_event.c 	assert(pq-&gt;timersEnabled);	// it would suck if this went off when timers were disabled
<a href='../S/21.html#L343'>pq</a>                343 cbench/oflops/wc_event.c 	pq-&gt;timersEnabled=0;		// mark timers as disabled (they can't go off anyway while we are here)
<a href='../S/21.html#L344'>pq</a>                344 cbench/oflops/wc_event.c 	wc_run_next_event(pq);
<a href='../S/21.html#L345'>pq</a>                345 cbench/oflops/wc_event.c 	pq-&gt;timersEnabled=1;		// re-enabled them
<a href='../S/21.html#L346'>pq</a>                346 cbench/oflops/wc_event.c 	if(!wc_queue_isempty(pq))
<a href='../S/21.html#L347'>pq</a>                347 cbench/oflops/wc_event.c 		wc_schedule_next_event(pq);	// schedule next event, if exists
<a href='../S/21.html#L356'>pq</a>                356 cbench/oflops/wc_event.c void wc_queue_double(wc_queue *pq){
<a href='../S/21.html#L361'>pq</a>                361 cbench/oflops/wc_event.c 	neoarray = malloc_and_check(sizeof(qelm)*pq-&gt;length*2);
<a href='../S/21.html#L363'>pq</a>                363 cbench/oflops/wc_event.c 	memcpy(neoarray,pq-&gt;array,pq-&gt;length*sizeof(qelm));
<a href='../S/21.html#L364'>pq</a>                364 cbench/oflops/wc_event.c 	pq-&gt;length*=2;
<a href='../S/21.html#L365'>pq</a>                365 cbench/oflops/wc_event.c 	if(pq-&gt;array)
<a href='../S/21.html#L366'>pq</a>                366 cbench/oflops/wc_event.c 		free(pq-&gt;array);
<a href='../S/21.html#L367'>pq</a>                367 cbench/oflops/wc_event.c 	pq-&gt;array=neoarray;
<a href='../S/21.html#L373'>pq</a>                373 cbench/oflops/wc_event.c void wc_disable_timers(struct wc_queue *pq)
<a href='../S/21.html#L383'>pq</a>                383 cbench/oflops/wc_event.c 	pq-&gt;timersEnabled=0;
<a href='../S/21.html#L412'>pq</a>                412 cbench/oflops/wc_event.c void wc_enable_timers(struct wc_queue *pq)
<a href='../S/21.html#L414'>pq</a>                414 cbench/oflops/wc_event.c 	pq-&gt;timersEnabled=1;
<a href='../S/21.html#L416'>pq</a>                416 cbench/oflops/wc_event.c 	if(!wc_queue_isempty(pq))
<a href='../S/21.html#L417'>pq</a>                417 cbench/oflops/wc_event.c 		wc_schedule_next_event(pq);
<a href='../S/21.html#L426'>pq</a>                426 cbench/oflops/wc_event.c static void verify_heap(wc_queue *pq)
<a href='../S/21.html#L429'>pq</a>                429 cbench/oflops/wc_event.c 	for(i=1;i&lt;=pq-&gt;size;i++)
<a href='../S/21.html#L431'>pq</a>                431 cbench/oflops/wc_event.c 		if(LEFT(i)&lt;=pq-&gt;size)
<a href='../S/21.html#L432'>pq</a>                432 cbench/oflops/wc_event.c 			assert( timercmp(&amp;pq-&gt;array[LEFT(i)].key,&amp;pq-&gt;array[i].key,&gt;=));
<a href='../S/21.html#L433'>pq</a>                433 cbench/oflops/wc_event.c 		if(RIGHT(i)&lt;=pq-&gt;size)
<a href='../S/21.html#L434'>pq</a>                434 cbench/oflops/wc_event.c 			assert( timercmp(&amp;pq-&gt;array[RIGHT(i)].key,&amp;pq-&gt;array[i].key,&gt;=));
<a href='../S/21.html#L455'>pq</a>                455 cbench/oflops/wc_event.c 	wc_queue *pq;
<a href='../S/21.html#L465'>pq</a>                465 cbench/oflops/wc_event.c 	pq = wc_queue_init(5);
<a href='../S/21.html#L490'>pq</a>                490 cbench/oflops/wc_event.c 				wc_event_add(pq,test_fun, (void *)&amp;t[i],times[i]));
<a href='../S/21.html#L493'>pq</a>                493 cbench/oflops/wc_event.c 	assert(wc_event_remove(pq,3,&amp;fun,&amp;arg)==0);
<a href='../S/21.html#L494'>pq</a>                494 cbench/oflops/wc_event.c 	assert(wc_event_remove(pq,0,&amp;fun,&amp;arg)==0);
<a href='../S/21.html#L495'>pq</a>                495 cbench/oflops/wc_event.c 	assert(wc_event_remove(pq,7,&amp;fun,&amp;arg)==0);
<a href='../S/21.html#L501'>pq</a>                501 cbench/oflops/wc_event.c 	wc_queue_free(pq);
<a href='../S/35.html#L38'>pq</a>                 38 cbench/oflops/wc_event.h int wc_queue_extract(struct wc_queue *pq , int *, struct timeval * key, void (**fun)(void *), void **arg);
</pre>
</body>
</html>
