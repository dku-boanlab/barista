<html>
<head>
<title>context</title>
<meta name='robots' content='noindex,nofollow'>
<meta name='generator' content='GLOBAL-5.7.1'>
</head>
<body text='#191970' bgcolor='#f5f5dc' vlink='gray'>
<pre>
<a href='../S/798.html#L72'>context</a>            72 cbench/openflow/secchan/emerg-flow.c 	struct emerg_flow_context *context = context_;
<a href='../S/798.html#L75'>context</a>            75 cbench/openflow/secchan/emerg-flow.c 			 context-&gt;state == PRIVATEOPT_EMERG_FLOW_RESTORATION
<a href='../S/798.html#L77'>context</a>            77 cbench/openflow/secchan/emerg-flow.c 			 : context-&gt;state == PRIVATEOPT_EMERG_FLOW_PROTECTION
<a href='../S/798.html#L84'>context</a>            84 cbench/openflow/secchan/emerg-flow.c 	struct emerg_flow_context *context = context_;
<a href='../S/798.html#L90'>context</a>            90 cbench/openflow/secchan/emerg-flow.c 	if (rconn_is_connected(context-&gt;remote_rconn)) {
<a href='../S/798.html#L91'>context</a>            91 cbench/openflow/secchan/emerg-flow.c 		if (context-&gt;state == PRIVATEOPT_EMERG_FLOW_PROTECTION) {
<a href='../S/798.html#L92'>context</a>            92 cbench/openflow/secchan/emerg-flow.c 			context-&gt;prev_state = context-&gt;state;
<a href='../S/798.html#L93'>context</a>            93 cbench/openflow/secchan/emerg-flow.c 			context-&gt;state = PRIVATEOPT_EMERG_FLOW_RESTORATION;
<a href='../S/798.html#L98'>context</a>            98 cbench/openflow/secchan/emerg-flow.c 		if (context-&gt;state == PRIVATEOPT_EMERG_FLOW_RESTORATION) {
<a href='../S/798.html#L99'>context</a>            99 cbench/openflow/secchan/emerg-flow.c 			context-&gt;prev_state = context-&gt;state;
<a href='../S/798.html#L100'>context</a>           100 cbench/openflow/secchan/emerg-flow.c 			context-&gt;state = PRIVATEOPT_EMERG_FLOW_PROTECTION;
<a href='../S/798.html#L110'>context</a>           110 cbench/openflow/secchan/emerg-flow.c 	vxopt-&gt;pvo_type = htons(context-&gt;state);
<a href='../S/798.html#L113'>context</a>           113 cbench/openflow/secchan/emerg-flow.c 	error = rconn_send(context-&gt;local_rconn, buf, NULL);
<a href='../S/798.html#L124'>context</a>           124 cbench/openflow/secchan/emerg-flow.c 	struct emerg_flow_context *context = NULL;
<a href='../S/798.html#L133'>context</a>           133 cbench/openflow/secchan/emerg-flow.c 	context = xmalloc(sizeof(*context));
<a href='../S/798.html#L134'>context</a>           134 cbench/openflow/secchan/emerg-flow.c 	context-&gt;settings = settings;
<a href='../S/798.html#L135'>context</a>           135 cbench/openflow/secchan/emerg-flow.c 	context-&gt;secchan = secchan;
<a href='../S/798.html#L136'>context</a>           136 cbench/openflow/secchan/emerg-flow.c 	context-&gt;local_rconn = local_rconn;
<a href='../S/798.html#L137'>context</a>           137 cbench/openflow/secchan/emerg-flow.c 	context-&gt;remote_rconn = remote_rconn;
<a href='../S/798.html#L138'>context</a>           138 cbench/openflow/secchan/emerg-flow.c 	context-&gt;prev_state = PRIVATEOPT_EMERG_FLOW_PROTECTION;
<a href='../S/798.html#L139'>context</a>           139 cbench/openflow/secchan/emerg-flow.c 	context-&gt;state = PRIVATEOPT_EMERG_FLOW_PROTECTION;
<a href='../S/798.html#L142'>context</a>           142 cbench/openflow/secchan/emerg-flow.c 					emerg_flow_status_cb, context);
<a href='../S/798.html#L143'>context</a>           143 cbench/openflow/secchan/emerg-flow.c 	add_hook(secchan, &amp;emerg_flow_hook_class, context);
<a href='../S/799.html#L67'>context</a>            67 cbench/openflow/secchan/failover.c 	struct failover_context *context = context_;
<a href='../S/799.html#L71'>context</a>            71 cbench/openflow/secchan/failover.c 			 context-&gt;settings-&gt;num_controllers);
<a href='../S/799.html#L74'>context</a>            74 cbench/openflow/secchan/failover.c 		if (context-&gt;settings-&gt;controller_names[i] == NULL)
<a href='../S/799.html#L77'>context</a>            77 cbench/openflow/secchan/failover.c 				 i, context-&gt;settings-&gt;controller_names[i]);
<a href='../S/799.html#L91'>context</a>            91 cbench/openflow/secchan/failover.c 	struct failover_context *context = context_;
<a href='../S/799.html#L95'>context</a>            95 cbench/openflow/secchan/failover.c 	if (rconn_is_connected(context-&gt;remote_rconn))
<a href='../S/799.html#L98'>context</a>            98 cbench/openflow/secchan/failover.c 	if (!is_timed_out(context-&gt;peers[context-&gt;index],
<a href='../S/799.html#L99'>context</a>            99 cbench/openflow/secchan/failover.c 			  context-&gt;settings-&gt;max_backoff)) {
<a href='../S/799.html#L103'>context</a>           103 cbench/openflow/secchan/failover.c 	rconn_disconnect(context-&gt;remote_rconn);
<a href='../S/799.html#L104'>context</a>           104 cbench/openflow/secchan/failover.c 	prev_peer = (char *)context-&gt;settings-&gt;controller_names[context-&gt;index];
<a href='../S/799.html#L105'>context</a>           105 cbench/openflow/secchan/failover.c 	context-&gt;index = (context-&gt;index + 1)
<a href='../S/799.html#L106'>context</a>           106 cbench/openflow/secchan/failover.c 		% context-&gt;settings-&gt;num_controllers;
<a href='../S/799.html#L107'>context</a>           107 cbench/openflow/secchan/failover.c 	curr_peer = (char *)context-&gt;settings-&gt;controller_names[context-&gt;index];
<a href='../S/799.html#L108'>context</a>           108 cbench/openflow/secchan/failover.c 	rconn_connect(context-&gt;remote_rconn,
<a href='../S/799.html#L109'>context</a>           109 cbench/openflow/secchan/failover.c 		      context-&gt;settings-&gt;controller_names[context-&gt;index]);
<a href='../S/799.html#L110'>context</a>           110 cbench/openflow/secchan/failover.c 	context-&gt;peers[context-&gt;index]-&gt;epoch = time_now();
<a href='../S/799.html#L118'>context</a>           118 cbench/openflow/secchan/failover.c 	struct failover_context *context = NULL;
<a href='../S/799.html#L128'>context</a>           128 cbench/openflow/secchan/failover.c 	context = xmalloc(sizeof(*context));
<a href='../S/799.html#L129'>context</a>           129 cbench/openflow/secchan/failover.c 	context-&gt;settings = settings;
<a href='../S/799.html#L130'>context</a>           130 cbench/openflow/secchan/failover.c 	context-&gt;secchan = secchan;
<a href='../S/799.html#L131'>context</a>           131 cbench/openflow/secchan/failover.c 	context-&gt;remote_rconn = remote_rconn;
<a href='../S/799.html#L132'>context</a>           132 cbench/openflow/secchan/failover.c 	context-&gt;index = 0;
<a href='../S/799.html#L134'>context</a>           134 cbench/openflow/secchan/failover.c 		context-&gt;peers[i] = NULL;
<a href='../S/799.html#L137'>context</a>           137 cbench/openflow/secchan/failover.c 		context-&gt;peers[i] = xmalloc(sizeof(struct failover_peer));
<a href='../S/799.html#L138'>context</a>           138 cbench/openflow/secchan/failover.c 		context-&gt;peers[i]-&gt;epoch = time_now();
<a href='../S/799.html#L142'>context</a>           142 cbench/openflow/secchan/failover.c 					failover_status_cb, context);
<a href='../S/799.html#L143'>context</a>           143 cbench/openflow/secchan/failover.c 	add_hook(secchan, &amp;failover_hook_class, context);
<a href='../S/792.html#L133'>context</a>           133 cbench/openflow/secchan/protocol-stat.c 	struct protocol_stat_context *context = context_;
<a href='../S/792.html#L167'>context</a>           167 cbench/openflow/secchan/protocol-stat.c 	rconn_update_protocol_stat(context-&gt;remote_rconn,
<a href='../S/792.html#L186'>context</a>           186 cbench/openflow/secchan/protocol-stat.c 	struct protocol_stat_context *context = NULL;
<a href='../S/792.html#L195'>context</a>           195 cbench/openflow/secchan/protocol-stat.c 	context = xmalloc(sizeof(*context));
<a href='../S/792.html#L196'>context</a>           196 cbench/openflow/secchan/protocol-stat.c 	context-&gt;settings = settings;
<a href='../S/792.html#L197'>context</a>           197 cbench/openflow/secchan/protocol-stat.c 	context-&gt;secchan = secchan;
<a href='../S/792.html#L198'>context</a>           198 cbench/openflow/secchan/protocol-stat.c 	context-&gt;local_rconn = local_rconn;
<a href='../S/792.html#L199'>context</a>           199 cbench/openflow/secchan/protocol-stat.c 	context-&gt;remote_rconn = remote_rconn;
<a href='../S/792.html#L200'>context</a>           200 cbench/openflow/secchan/protocol-stat.c 	memset(&amp;context-&gt;ofps_rcvd, 0, sizeof(context-&gt;ofps_rcvd));
<a href='../S/792.html#L201'>context</a>           201 cbench/openflow/secchan/protocol-stat.c 	memset(&amp;context-&gt;ofps_sent, 0, sizeof(context-&gt;ofps_sent));
<a href='../S/792.html#L203'>context</a>           203 cbench/openflow/secchan/protocol-stat.c 	add_hook(secchan, &amp;protocol_stat_hook_class, context);
<a href='../S/487.html#L34'>context</a>            34 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/codecs.h typedef void (*codec_release_fn)(void *context);
<a href='../S/487.html#L35'>context</a>            35 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/codecs.h typedef int (*codec_decode_fn)(void *context, const void *input, int inputSizeBytes, void *output, int *outputSizeBytes);
<a href='../S/487.html#L40'>context</a>            40 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/codecs.h extern void codec_release(codec_handle_t codec, void *context);
<a href='../S/487.html#L41'>context</a>            41 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/codecs.h extern int codec_decode(codec_handle_t codec, void *context, const void *input, int inputSizeBytes, void *output, int *outputSizeBytes);
<a href='../S/358.html#L59'>context</a>            59 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/tcap-persistentdata.h   struct tcaphash_context_t * context;
<a href='../S/358.html#L67'>context</a>            67 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/tcap-persistentdata.h   struct tcaphash_context_t * context;
<a href='../S/358.html#L75'>context</a>            75 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/tcap-persistentdata.h   struct tcaphash_context_t * context;
<a href='../S/358.html#L83'>context</a>            83 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/tcap-persistentdata.h   struct tcaphash_context_t * context;
<a href='../S/362.html#L608'>context</a>           608 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/xmlstub.h typedef int (*xmlInputReadCallback) (void * context, char * buffer, int len);
<a href='../S/362.html#L609'>context</a>           609 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/xmlstub.h typedef void (*xmlInputCloseCallback) (void * context);
<a href='../S/362.html#L614'>context</a>           614 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/xmlstub.h     void*                  context;
<a href='../S/362.html#L632'>context</a>           632 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/xmlstub.h typedef int (*xmlOutputWriteCallback) (void * context, const char * buffer,
<a href='../S/362.html#L634'>context</a>           634 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/xmlstub.h typedef void (*xmlOutputCloseCallback) (void * context);
<a href='../S/362.html#L639'>context</a>           639 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/xmlstub.h     void*                   context;
<a href='../S/362.html#L1066'>context</a>          1066 cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/xmlstub.h                                                      xmlParserCtxtPtr context);
<a href='../S/1002.html#L119'>context</a>           119 components/conn.c context_t *context;
<a href='../S/1002.html#L127'>context</a>           127 components/conn.c     context = (context_t *)CALLOC(__DEFAULT_TABLE_SIZE, sizeof(context_t));
<a href='../S/1002.html#L128'>context</a>           128 components/conn.c     if (context == NULL) {
<a href='../S/1002.html#L140'>context</a>           140 components/conn.c     if (context)
<a href='../S/1002.html#L141'>context</a>           141 components/conn.c         memset(&amp;context[sock], 0, sizeof(context_t));
<a href='../S/1002.html#L154'>context</a>           154 components/conn.c     context_t *c = &amp;context[sock];
<a href='../S/1002.html#L648'>context</a>           648 components/conn.c     FREE(context);
<a href='../S/1009.html#L119'>context</a>           119 components/conn_sb.c context_t *context;
<a href='../S/1009.html#L127'>context</a>           127 components/conn_sb.c     context = (context_t *)CALLOC(__DEFAULT_TABLE_SIZE, sizeof(context_t));
<a href='../S/1009.html#L128'>context</a>           128 components/conn_sb.c     if (context == NULL) {
<a href='../S/1009.html#L140'>context</a>           140 components/conn_sb.c     if (context)
<a href='../S/1009.html#L141'>context</a>           141 components/conn_sb.c         memset(&amp;context[sock], 0, sizeof(context_t));
<a href='../S/1009.html#L154'>context</a>           154 components/conn_sb.c     context_t *c = &amp;context[sock];
<a href='../S/1009.html#L653'>context</a>           653 components/conn_sb.c     FREE(context);
<a href='../S/1090.html#L2223'>context</a>          2223 libraries/libcli/libcli.c void cli_set_context(struct cli_def *cli, void *context) {
<a href='../S/1090.html#L2224'>context</a>          2224 libraries/libcli/libcli.c     cli-&gt;user_context = context;
<a href='../S/1091.html#L126'>context</a>           126 libraries/libcli/libcli.h void cli_set_context(struct cli_def *cli, void *context);
</pre>
</body>
</html>
