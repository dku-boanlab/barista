<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Barista: cbench/openflow/utilities/wireshark_dissectors/wireshark-1.0.0-includes/epan/tvbuff.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Barista
   &#160;<span id="projectnumber">1.0.0 (Americano)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tvbuff_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvbuff.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;glib.h&gt;</code><br/>
<code>#include &lt;epan/ipv6-utils.h&gt;</code><br/>
<code>#include &lt;epan/guid-utils.h&gt;</code><br/>
<code>#include &quot;exceptions.h&quot;</code><br/>
</div>
<p><a href="HTML/S/422.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvb__backing__t.html">tvb_backing_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvb__comp__t.html">tvb_comp_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvbuff.html">tvbuff</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab884449a8a680bd64d17504d58cb6054"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab884449a8a680bd64d17504d58cb6054"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TVB_RAW_OFFSET</b>(tvb)&#160;&#160;&#160;((tvb-&gt;raw_offset==-1)?(tvb-&gt;raw_offset = offset_from_real_beginning(tvb, 0)):tvb-&gt;raw_offset)</td></tr>
<tr class="separator:ab884449a8a680bd64d17504d58cb6054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482e9e90e8e5c7c8de58ee470fd83cb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a482e9e90e8e5c7c8de58ee470fd83cb7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TVB_GET_DS_TVB</b>(tvb)&#160;&#160;&#160;(tvb-&gt;ds_tvb)</td></tr>
<tr class="separator:a482e9e90e8e5c7c8de58ee470fd83cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0531b6bf91be1a4063266e606f5bedfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0531b6bf91be1a4063266e606f5bedfa"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tvbuff_free_cb_t</b> )(void *)</td></tr>
<tr class="separator:a0531b6bf91be1a4063266e606f5bedfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec87e81dc00f76b1d9ddb75ba36a2016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec87e81dc00f76b1d9ddb75ba36a2016"></a>
typedef struct <a class="el" href="structtvbuff.html">tvbuff</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tvbuff_t</b></td></tr>
<tr class="separator:aec87e81dc00f76b1d9ddb75ba36a2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9e46572a63e9cfa8f496c7fead8a4320"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a9e46572a63e9cfa8f496c7fead8a4320">tvbuff_type</a> { <b>TVBUFF_REAL_DATA</b>, 
<b>TVBUFF_SUBSET</b>, 
<b>TVBUFF_COMPOSITE</b>
 }</td></tr>
<tr class="separator:a9e46572a63e9cfa8f496c7fead8a4320"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6470945c7d80497cc773c5564c8f6355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a6470945c7d80497cc773c5564c8f6355">tvbuff_init</a> (void)</td></tr>
<tr class="separator:a6470945c7d80497cc773c5564c8f6355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac230490546afc3c91d1460ee75605b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#ac230490546afc3c91d1460ee75605b6c">tvbuff_cleanup</a> (void)</td></tr>
<tr class="separator:ac230490546afc3c91d1460ee75605b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fae01a75f429ddf3a1d1f4d6d3dcfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#ac3fae01a75f429ddf3a1d1f4d6d3dcfd">tvb_new</a> (<a class="el" href="tvbuff_8h.html#a9e46572a63e9cfa8f496c7fead8a4320">tvbuff_type</a>)</td></tr>
<tr class="separator:ac3fae01a75f429ddf3a1d1f4d6d3dcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082f5b738d1bdc83344762bdbf4e66db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a082f5b738d1bdc83344762bdbf4e66db">tvb_free</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *)</td></tr>
<tr class="separator:a082f5b738d1bdc83344762bdbf4e66db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3788ab7eafa812c9d73d2ebe403c15c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a3788ab7eafa812c9d73d2ebe403c15c1">tvb_free_chain</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *)</td></tr>
<tr class="separator:a3788ab7eafa812c9d73d2ebe403c15c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dbbdfd540b824f17c035f0663f119f"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a47dbbdfd540b824f17c035f0663f119f">tvb_increment_usage_count</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, guint count)</td></tr>
<tr class="separator:a47dbbdfd540b824f17c035f0663f119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b058a17e3bd5aaf524ed1f96bc47136"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a0b058a17e3bd5aaf524ed1f96bc47136">tvb_decrement_usage_count</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, guint count)</td></tr>
<tr class="separator:a0b058a17e3bd5aaf524ed1f96bc47136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5964b79a9b99108a2300ac5b137423d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a5964b79a9b99108a2300ac5b137423d0">tvb_set_free_cb</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, tvbuff_free_cb_t)</td></tr>
<tr class="separator:a5964b79a9b99108a2300ac5b137423d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2c676a6ac7889b4a4d1f586177fc0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a6d2c676a6ac7889b4a4d1f586177fc0f">tvb_set_child_real_data_tvbuff</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *parent, <a class="el" href="structtvbuff.html">tvbuff_t</a> *child)</td></tr>
<tr class="separator:a6d2c676a6ac7889b4a4d1f586177fc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ed1a2cb684d94c639344da11e46aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a81ed1a2cb684d94c639344da11e46aa9">tvb_set_real_data</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, const guint8 *data, guint length, gint reported_length)</td></tr>
<tr class="separator:a81ed1a2cb684d94c639344da11e46aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1be3270c3897c6c5e688b8f96a0324b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#ad1be3270c3897c6c5e688b8f96a0324b">tvb_new_real_data</a> (const guint8 *data, guint length, gint reported_length)</td></tr>
<tr class="separator:ad1be3270c3897c6c5e688b8f96a0324b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083d74786a89289b31e3909350f0f100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a083d74786a89289b31e3909350f0f100">tvb_set_subset</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, <a class="el" href="structtvbuff.html">tvbuff_t</a> *backing, gint backing_offset, gint backing_length, gint reported_length)</td></tr>
<tr class="separator:a083d74786a89289b31e3909350f0f100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94052a5a6ddf1629173d426746e7ed13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a94052a5a6ddf1629173d426746e7ed13">tvb_new_subset</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *backing, gint backing_offset, gint backing_length, gint reported_length)</td></tr>
<tr class="separator:a94052a5a6ddf1629173d426746e7ed13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a80606a0813dca2158c314a0c0c3de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#aa1a80606a0813dca2158c314a0c0c3de">tvb_composite_append</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, <a class="el" href="structtvbuff.html">tvbuff_t</a> *member)</td></tr>
<tr class="separator:aa1a80606a0813dca2158c314a0c0c3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0d9a81e6b26c1fba38fa01115950be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#afa0d9a81e6b26c1fba38fa01115950be">tvb_composite_prepend</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, <a class="el" href="structtvbuff.html">tvbuff_t</a> *member)</td></tr>
<tr class="separator:afa0d9a81e6b26c1fba38fa01115950be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa919b43fdba78f4be4a76aa274e6cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#aaa919b43fdba78f4be4a76aa274e6cce">tvb_new_composite</a> (void)</td></tr>
<tr class="separator:aaa919b43fdba78f4be4a76aa274e6cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966b603dff9304bfd70d6a8adbde03e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a966b603dff9304bfd70d6a8adbde03e0">tvb_composite_finalize</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb)</td></tr>
<tr class="separator:a966b603dff9304bfd70d6a8adbde03e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dc6f831460070007a99639ff1348c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8dc6f831460070007a99639ff1348c5"></a>
guint&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_length</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *)</td></tr>
<tr class="separator:ae8dc6f831460070007a99639ff1348c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9cc505773f07f1932f9204777ac8f1"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#aab9cc505773f07f1932f9204777ac8f1">tvb_length_remaining</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:aab9cc505773f07f1932f9204777ac8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b6e571cc7ffc383c281325b95510b6"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a61b6e571cc7ffc383c281325b95510b6">tvb_ensure_length_remaining</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a61b6e571cc7ffc383c281325b95510b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab771085bb76a81e0c2f1e09a059f2255"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab771085bb76a81e0c2f1e09a059f2255"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_bytes_exist</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset, gint length)</td></tr>
<tr class="separator:ab771085bb76a81e0c2f1e09a059f2255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c4a0c9b2e34a56ce5fc23a566baceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#ad0c4a0c9b2e34a56ce5fc23a566baceb">tvb_ensure_bytes_exist</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint length)</td></tr>
<tr class="separator:ad0c4a0c9b2e34a56ce5fc23a566baceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c221cf364105d862df5379142ea53d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c221cf364105d862df5379142ea53d7"></a>
gboolean&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_offset_exists</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a4c221cf364105d862df5379142ea53d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9244bbc913504b1bc90bd0c8f1af90e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9244bbc913504b1bc90bd0c8f1af90e6"></a>
guint&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_reported_length</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *)</td></tr>
<tr class="separator:a9244bbc913504b1bc90bd0c8f1af90e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff6d1c9ee0d773fc88d2a3cbe7fb2b7"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a0ff6d1c9ee0d773fc88d2a3cbe7fb2b7">tvb_reported_length_remaining</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset)</td></tr>
<tr class="separator:a0ff6d1c9ee0d773fc88d2a3cbe7fb2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b02b4fbab1fd6fbeff362448bcd0f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a73b02b4fbab1fd6fbeff362448bcd0f4">tvb_set_reported_length</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, guint)</td></tr>
<tr class="separator:a73b02b4fbab1fd6fbeff362448bcd0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa454d4aa01502c1594b0b7098977786f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa454d4aa01502c1594b0b7098977786f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>offset_from_real_beginning</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, int counter)</td></tr>
<tr class="separator:aa454d4aa01502c1594b0b7098977786f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3087fa13b7c0aa1263858554ac4c14d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3087fa13b7c0aa1263858554ac4c14d"></a>
guint8&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_guint8</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:ad3087fa13b7c0aa1263858554ac4c14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7988741face1b5cfdf621b943865eb1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7988741face1b5cfdf621b943865eb1a"></a>
guint16&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ntohs</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a7988741face1b5cfdf621b943865eb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65f2a5ba1b7e1299bd3a5a46c40368c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab65f2a5ba1b7e1299bd3a5a46c40368c"></a>
guint32&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ntoh24</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:ab65f2a5ba1b7e1299bd3a5a46c40368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ca12add6206675aafbddc9d3ca7f04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76ca12add6206675aafbddc9d3ca7f04"></a>
guint32&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ntohl</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a76ca12add6206675aafbddc9d3ca7f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe1c89ac55d722b7c70b5deedd771f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fe1c89ac55d722b7c70b5deedd771f0"></a>
guint64&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ntoh64</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a5fe1c89ac55d722b7c70b5deedd771f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea034b1fb68ce5a7c5c3cfb53675d0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ea034b1fb68ce5a7c5c3cfb53675d0d"></a>
gfloat&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ntohieee_float</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a9ea034b1fb68ce5a7c5c3cfb53675d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35096aac2649e6f0cf487cef2492940d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35096aac2649e6f0cf487cef2492940d"></a>
gdouble&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ntohieee_double</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a35096aac2649e6f0cf487cef2492940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd421f61d66a8724a36ccb41e9d733ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd421f61d66a8724a36ccb41e9d733ac"></a>
guint16&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_letohs</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:acd421f61d66a8724a36ccb41e9d733ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7636f7fd660de8213938ae86a45e6ee4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7636f7fd660de8213938ae86a45e6ee4"></a>
guint32&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_letoh24</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a7636f7fd660de8213938ae86a45e6ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91893b3a0cc75f0553d478719f6b1ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af91893b3a0cc75f0553d478719f6b1ce"></a>
guint32&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_letohl</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:af91893b3a0cc75f0553d478719f6b1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2398c441b1407093ccb76470cf30c52b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2398c441b1407093ccb76470cf30c52b"></a>
guint64&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_letoh64</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a2398c441b1407093ccb76470cf30c52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac046269b33756b9c157df39106af84a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac046269b33756b9c157df39106af84a6"></a>
gfloat&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_letohieee_float</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:ac046269b33756b9c157df39106af84a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ff9aded433d081e94f4eb005721d85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32ff9aded433d081e94f4eb005721d85"></a>
gdouble&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_letohieee_double</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a32ff9aded433d081e94f4eb005721d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e26051278d3d18241c70468dc1a738"><td class="memItemLeft" align="right" valign="top">guint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a20e26051278d3d18241c70468dc1a738">tvb_get_ipv4</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset)</td></tr>
<tr class="separator:a20e26051278d3d18241c70468dc1a738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae68986d6285f4f0510d2503f52ba56f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae68986d6285f4f0510d2503f52ba56f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ipv6</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset, struct <a class="el" href="structe__in6__addr.html">e_in6_addr</a> *addr)</td></tr>
<tr class="separator:aae68986d6285f4f0510d2503f52ba56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c9335e3f1d5d2c714112e0cde22c5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64c9335e3f1d5d2c714112e0cde22c5b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ntohguid</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, <a class="el" href="struct__e__guid__t.html">e_guid_t</a> *guid)</td></tr>
<tr class="separator:a64c9335e3f1d5d2c714112e0cde22c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b8d8731d0bba16d3eb4e5454df23f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29b8d8731d0bba16d3eb4e5454df23f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_letohguid</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, <a class="el" href="struct__e__guid__t.html">e_guid_t</a> *guid)</td></tr>
<tr class="separator:a29b8d8731d0bba16d3eb4e5454df23f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a033c9dc6bb0db476ae50bca0316ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1a033c9dc6bb0db476ae50bca0316ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_guid</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, <a class="el" href="struct__e__guid__t.html">e_guid_t</a> *guid, gboolean little_endian)</td></tr>
<tr class="separator:ad1a033c9dc6bb0db476ae50bca0316ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94a04aaf6d2dea6aee20656c33655f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa94a04aaf6d2dea6aee20656c33655f1"></a>
guint8&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_bits8</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint bit_offset, gint no_of_bits)</td></tr>
<tr class="separator:aa94a04aaf6d2dea6aee20656c33655f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7a6bd0d6c57dc8d15b745675303c0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb7a6bd0d6c57dc8d15b745675303c0c"></a>
guint16&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_bits16</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint bit_offset, gint no_of_bits, gboolean little_endian)</td></tr>
<tr class="separator:acb7a6bd0d6c57dc8d15b745675303c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e23ed356f1dfd845d27b5f4c302e7c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e23ed356f1dfd845d27b5f4c302e7c8"></a>
guint32&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_bits32</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint bit_offset, gint no_of_bits, gboolean little_endian)</td></tr>
<tr class="separator:a1e23ed356f1dfd845d27b5f4c302e7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4996b2d0834bc5b72c525df81ed93d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e4996b2d0834bc5b72c525df81ed93d"></a>
guint64&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_bits64</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint bit_offset, gint no_of_bits, gboolean little_endian)</td></tr>
<tr class="separator:a2e4996b2d0834bc5b72c525df81ed93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe01bb7439c8f77a02727c4bef62e56c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#abe01bb7439c8f77a02727c4bef62e56c">tvb_memcpy</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, void *target, gint offset, gint length)</td></tr>
<tr class="separator:abe01bb7439c8f77a02727c4bef62e56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3308c19cf00a7aabfe3c327589d0ec42"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a3308c19cf00a7aabfe3c327589d0ec42">tvb_memdup</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset, gint length)</td></tr>
<tr class="separator:a3308c19cf00a7aabfe3c327589d0ec42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a976c5da0e4c1ab493a44a6f5671a4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a976c5da0e4c1ab493a44a6f5671a4d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>ep_tvb_memdup</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint length)</td></tr>
<tr class="separator:a9a976c5da0e4c1ab493a44a6f5671a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83005861c45fae75b73685fb06192e9"><td class="memItemLeft" align="right" valign="top">const guint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#ae83005861c45fae75b73685fb06192e9">tvb_get_ptr</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset, gint length)</td></tr>
<tr class="separator:ae83005861c45fae75b73685fb06192e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50996a31e8328200b3ff4379025fe03"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#ac50996a31e8328200b3ff4379025fe03">tvb_find_guint8</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset, gint maxlength, guint8 needle)</td></tr>
<tr class="separator:ac50996a31e8328200b3ff4379025fe03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ad57c39979942fed7bf8beaca09aa7"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a94ad57c39979942fed7bf8beaca09aa7">tvb_pbrk_guint8</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset, gint maxlength, const guint8 *needles)</td></tr>
<tr class="separator:a94ad57c39979942fed7bf8beaca09aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec98961ab4a0e137d107943ab80cb532"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#aec98961ab4a0e137d107943ab80cb532">tvb_strsize</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset)</td></tr>
<tr class="separator:aec98961ab4a0e137d107943ab80cb532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27da69ebed5c60023d054da0e475b2a7"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a27da69ebed5c60023d054da0e475b2a7">tvb_strnlen</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *, gint offset, guint maxlength)</td></tr>
<tr class="separator:a27da69ebed5c60023d054da0e475b2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513526b846e5b34a3d862361e139dbb3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a513526b846e5b34a3d862361e139dbb3">tvb_fake_unicode</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, int offset, int len, gboolean little_endian)</td></tr>
<tr class="separator:a513526b846e5b34a3d862361e139dbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48672a6a654e434151c19dc1aee50dc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48672a6a654e434151c19dc1aee50dc5"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ephemeral_faked_unicode</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, int offset, int len, gboolean little_endian)</td></tr>
<tr class="separator:a48672a6a654e434151c19dc1aee50dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f3c347eb9c9b37b654b0efdad4a528"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a39f3c347eb9c9b37b654b0efdad4a528">tvb_format_text</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint <a class="el" href="group__southbound.html#ga439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="separator:a39f3c347eb9c9b37b654b0efdad4a528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af695e07cf1245cf49ce95cbab4e1a002"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#af695e07cf1245cf49ce95cbab4e1a002">tvb_format_text_wsp</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint <a class="el" href="group__southbound.html#ga439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="separator:af695e07cf1245cf49ce95cbab4e1a002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe6c5da0c2efe67d924abe2cbcf5dca"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#abfe6c5da0c2efe67d924abe2cbcf5dca">tvb_format_stringzpad</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint <a class="el" href="group__southbound.html#ga439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="separator:abfe6c5da0c2efe67d924abe2cbcf5dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ad9b5546ebe7050b769df02298ad58"><td class="memItemLeft" align="right" valign="top">guint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#ac9ad9b5546ebe7050b769df02298ad58">tvb_get_string</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint length)</td></tr>
<tr class="separator:ac9ad9b5546ebe7050b769df02298ad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0540f1735cea95f9d3d8336b2d8bde19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0540f1735cea95f9d3d8336b2d8bde19"></a>
guint8 *&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ephemeral_string</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint length)</td></tr>
<tr class="separator:a0540f1735cea95f9d3d8336b2d8bde19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af831b2d20a4964fab41f4c4781611ea0"><td class="memItemLeft" align="right" valign="top">guint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#af831b2d20a4964fab41f4c4781611ea0">tvb_get_stringz</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint *lengthp)</td></tr>
<tr class="separator:af831b2d20a4964fab41f4c4781611ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d2aef8632c65c7f24bca234855befd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02d2aef8632c65c7f24bca234855befd"></a>
guint8 *&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_get_ephemeral_stringz</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint *lengthp)</td></tr>
<tr class="separator:a02d2aef8632c65c7f24bca234855befd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a611d5fba78483ca46b1e4b7c8327b"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a37a611d5fba78483ca46b1e4b7c8327b">tvb_get_nstringz</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, guint bufsize, guint8 *buffer)</td></tr>
<tr class="separator:a37a611d5fba78483ca46b1e4b7c8327b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e059fc6e4a335080cb59d03843c1bb2"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a8e059fc6e4a335080cb59d03843c1bb2">tvb_get_nstringz0</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, guint bufsize, guint8 *buffer)</td></tr>
<tr class="separator:a8e059fc6e4a335080cb59d03843c1bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bc0712a87c4364f88202f6b7a0c2d2"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a24bc0712a87c4364f88202f6b7a0c2d2">tvb_find_line_end</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, int len, gint *next_offset, gboolean desegment)</td></tr>
<tr class="separator:a24bc0712a87c4364f88202f6b7a0c2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e2012dbad98b84e7c69b3a42e2ee49"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a93e2012dbad98b84e7c69b3a42e2ee49">tvb_find_line_end_unquoted</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, int len, gint *next_offset)</td></tr>
<tr class="separator:a93e2012dbad98b84e7c69b3a42e2ee49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e63caa7926ccb13c62db3ce6c294c8"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a15e63caa7926ccb13c62db3ce6c294c8">tvb_skip_wsp</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint maxlength)</td></tr>
<tr class="separator:a15e63caa7926ccb13c62db3ce6c294c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aad197f4a0b5fc7b715b55996742d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05aad197f4a0b5fc7b715b55996742d9"></a>
gint&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_skip_wsp_return</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset)</td></tr>
<tr class="separator:a05aad197f4a0b5fc7b715b55996742d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3291b012a0e6d15cee9a0460723cd92"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#ad3291b012a0e6d15cee9a0460723cd92">tvb_strneql</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, const gchar *str, gint <a class="el" href="group__southbound.html#ga439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="separator:ad3291b012a0e6d15cee9a0460723cd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0ec59e419e99c74d393c1597ff46f8"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a8f0ec59e419e99c74d393c1597ff46f8">tvb_strncaseeql</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, const gchar *str, gint <a class="el" href="group__southbound.html#ga439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="separator:a8f0ec59e419e99c74d393c1597ff46f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36912d356ceaae18c4647b700647c0e1"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a36912d356ceaae18c4647b700647c0e1">tvb_memeql</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, const guint8 *str, gint <a class="el" href="group__southbound.html#ga439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="separator:a36912d356ceaae18c4647b700647c0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9aacd7d1f8bf819cd1bb723218d4c0"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#a0c9aacd7d1f8bf819cd1bb723218d4c0">tvb_bytes_to_str_punct</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint len, gchar punct)</td></tr>
<tr class="separator:a0c9aacd7d1f8bf819cd1bb723218d4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce37d4e37ecefa5cc3c77da661736d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ce37d4e37ecefa5cc3c77da661736d7"></a>
gchar *&#160;</td><td class="memItemRight" valign="bottom"><b>tvb_bytes_to_str</b> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, gint offset, gint len)</td></tr>
<tr class="separator:a3ce37d4e37ecefa5cc3c77da661736d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68d4b45af10e03ec5f10b2533845464"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#af68d4b45af10e03ec5f10b2533845464">tvb_find_tvb</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *haystack_tvb, <a class="el" href="structtvbuff.html">tvbuff_t</a> *needle_tvb, gint haystack_offset)</td></tr>
<tr class="separator:af68d4b45af10e03ec5f10b2533845464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a1330890fd1debb533e0b3f37bc9cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tvbuff_8h.html#ae2a1330890fd1debb533e0b3f37bc9cf">tvb_uncompress</a> (<a class="el" href="structtvbuff.html">tvbuff_t</a> *tvb, int offset, int comprlen)</td></tr>
<tr class="separator:ae2a1330890fd1debb533e0b3f37bc9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>"testy, virtual(-izable) buffer". They are testy in that they get mad when an attempt is made to access data beyond the bounds of their array. In that case, they throw an exception.</p>
<p>They are virtualizable in that new tvbuff's can be made from other tvbuffs, while only the original tvbuff may have data. That is, the new tvbuff has virtual data. </p>

<p>Definition in file <a class="el" href="HTML/S/422.html">tvbuff.h</a>.</p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a9e46572a63e9cfa8f496c7fead8a4320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tvbuff_8h.html#a9e46572a63e9cfa8f496c7fead8a4320">tvbuff_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The different types of tvbuff's </p>

<p>Definition at line <a class="el" href="HTML/S/422.html#L59">59</a> of file <a class="el" href="HTML/S/422.html">tvbuff.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;             {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    TVBUFF_REAL_DATA,</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    TVBUFF_SUBSET,</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    TVBUFF_COMPOSITE</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;} <a class="code" href="tvbuff_8h.html#a9e46572a63e9cfa8f496c7fead8a4320">tvbuff_type</a>;</div>
<div class="ttc" id="tvbuff_8h_html_a9e46572a63e9cfa8f496c7fead8a4320"><div class="ttname"><a href="tvbuff_8h.html#a9e46572a63e9cfa8f496c7fead8a4320">tvbuff_type</a></div><div class="ttdeci">tvbuff_type</div><div class="ttdef"><b>Definition:</b> <a href="HTML/S/422.html#L59">tvbuff.h:59</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0c9aacd7d1f8bf819cd1bb723218d4c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar* tvb_bytes_to_str_punct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gchar&#160;</td>
          <td class="paramname"><em>punct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Format a bunch of data from a tvbuff as bytes, returning a pointer to the string with the formatted data, with "punct" as a byte separator. </p>

</div>
</div>
<a class="anchor" id="aa1a80606a0813dca2158c314a0c0c3de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_composite_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Both tvb_composite_append and tvb_composite_prepend can throw BoundsError if member_offset/member_length goes beyond bounds of the 'member' tvbuff. Append to the list of tvbuffs that make up this composite tvbuff </p>

</div>
</div>
<a class="anchor" id="a966b603dff9304bfd70d6a8adbde03e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_composite_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a composite tvbuff as initialized. No further appends or prepends occur, data access can finally happen after this finalization. </p>

</div>
</div>
<a class="anchor" id="afa0d9a81e6b26c1fba38fa01115950be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_composite_prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepend to the list of tvbuffs that make up this composite tvbuff </p>

</div>
</div>
<a class="anchor" id="a0b058a17e3bd5aaf524ed1f96bc47136"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint tvb_decrement_usage_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a decrement causes the usage count to drop to 0, a the tvbuff is immediately freed. Be sure you know exactly what you're doing if you decide to use this function, as another tvbuff could still have a pointer to the just-freed tvbuff, causing corrupted data or a segfault in the future </p>

</div>
</div>
<a class="anchor" id="ad0c4a0c9b2e34a56ce5fc23a566baceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_ensure_bytes_exist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the bytes referred to by 'offset'/'length' actually exist in the buffer, and throws an exception if they aren't. </p>

</div>
</div>
<a class="anchor" id="a61b6e571cc7ffc383c281325b95510b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint tvb_ensure_length_remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but throws an exception if the offset is out of bounds. </p>

</div>
</div>
<a class="anchor" id="a513526b846e5b34a3d862361e139dbb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tvb_fake_unicode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>little_endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a string from Unicode to ASCII. At the moment we fake it by assuming all characters are ASCII )-: The len parameter is the number of guint16's to convert from Unicode.</p>
<p><a class="el" href="tvbuff_8h.html#a513526b846e5b34a3d862361e139dbb3">tvb_fake_unicode()</a> returns a buffer allocated by g_malloc() and must be g_free() by the caller. tvb_get_ephemeral_faked_unicode() returns a buffer that does not need to be explicitely freed. Instead this buffer is automatically freed when wireshark starts dissecting the next packet. </p>

</div>
</div>
<a class="anchor" id="ac50996a31e8328200b3ff4379025fe03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_find_guint8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint8&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find first occurence of any of the needles in tvbuff, starting at offset. Searches at most maxlength number of bytes; if maxlength is -1, searches to end of tvbuff. Returns the offset of the found needle, or -1 if not found. Will not throw an exception, even if maxlength exceeds boundary of tvbuff; in that case, -1 will be returned if the boundary is reached before finding needle. </p>

</div>
</div>
<a class="anchor" id="a24bc0712a87c4364f88202f6b7a0c2d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_find_line_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint *&#160;</td>
          <td class="paramname"><em>next_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>desegment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a tvbuff, an offset into the tvbuff, and a length that starts at that offset (which may be -1 for "all the way to the end of the
tvbuff"), find the end of the (putative) line that starts at the specified offset in the tvbuff, going no further than the specified length.</p>
<p>Return the length of the line (not counting the line terminator at the end), or, if we don't find a line terminator:</p>
<p>if "deseg" is true, return -1;</p>
<p>if "deseg" is false, return the amount of data remaining in the buffer.</p>
<p>Set "*next_offset" to the offset of the character past the line terminator, or past the end of the buffer if we don't find a line terminator. (It's not set if we return -1.) </p>

</div>
</div>
<a class="anchor" id="a93e2012dbad98b84e7c69b3a42e2ee49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_find_line_end_unquoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint *&#160;</td>
          <td class="paramname"><em>next_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a tvbuff, an offset into the tvbuff, and a length that starts at that offset (which may be -1 for "all the way to the end of the
tvbuff"), find the end of the (putative) line that starts at the specified offset in the tvbuff, going no further than the specified length.</p>
<p>However, treat quoted strings inside the buffer specially - don't treat newlines in quoted strings as line terminators.</p>
<p>Return the length of the line (not counting the line terminator at the end), or the amount of data remaining in the buffer if we don't find a line terminator.</p>
<p>Set "*next_offset" to the offset of the character past the line terminator, or past the end of the buffer if we don't find a line terminator. </p>

</div>
</div>
<a class="anchor" id="af68d4b45af10e03ec5f10b2533845464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_find_tvb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>haystack_tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>needle_tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>haystack_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locate a sub-tvbuff within another tvbuff, starting at position 'haystack_offset'. Returns the index of the beginning of 'needle' within 'haystack', or -1 if 'needle' is not found. The index is relative to the start of 'haystack', not 'haystack_offset'. </p>

</div>
</div>
<a class="anchor" id="abfe6c5da0c2efe67d924abe2cbcf5dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar* tvb_format_stringzpad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like "tvb_format_text()", but for null-padded strings; don't show the null padding characters as "\000". </p>

</div>
</div>
<a class="anchor" id="a39f3c347eb9c9b37b654b0efdad4a528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar* tvb_format_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Format the data in the tvb from offset for size ... </p>

</div>
</div>
<a class="anchor" id="af695e07cf1245cf49ce95cbab4e1a002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar* tvb_format_text_wsp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like "tvb_format_text()", but for 'wsp'; don't show the characters as C-style escapes. </p>

</div>
</div>
<a class="anchor" id="a082f5b738d1bdc83344762bdbf4e66db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a tvbuff for freeing. The guint8* data of a TVBUFF_REAL_DATA is <em>never</em> freed by the tvbuff routines. The tvbuff itself is actually freed once its usage count drops to 0.</p>
<p>Usage counts increment for any time the tvbuff is used as a member of another tvbuff, i.e., as the backing buffer for a TVBUFF_SUBSET or as a member of a TVBUFF_COMPOSITE.</p>
<p>Although you may call <a class="el" href="tvbuff_8h.html#a082f5b738d1bdc83344762bdbf4e66db">tvb_free()</a>, the tvbuff may still be in use by other tvbuff's (TVBUFF_SUBSET or TVBUFF_COMPOSITE), so it is not safe, unless you know otherwise, to free your guint8* data. If you cannot be sure that your TVBUFF_REAL_DATA is not in use by another tvbuff, register a callback with <a class="el" href="tvbuff_8h.html#a5964b79a9b99108a2300ac5b137423d0">tvb_set_free_cb()</a>; when your tvbuff is <em>really</em> freed, then your callback will be called, and at that time you can free your original data.</p>
<p>The caller can artificially increment/decrement the usage count with tvbuff_increment_usage_count()/tvbuff_decrement_usage_count(). </p>

</div>
</div>
<a class="anchor" id="a3788ab7eafa812c9d73d2ebe403c15c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_free_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the tvbuff_t and all tvbuff's created from it. </p>

</div>
</div>
<a class="anchor" id="a20e26051278d3d18241c70468dc1a738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint32 tvb_get_ipv4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetch an IPv4 address, in network byte order. We do <em>not</em> convert it to host byte order; we leave it in network byte order, as that's what its callers expect. </p>

</div>
</div>
<a class="anchor" id="a37a611d5fba78483ca46b1e4b7c8327b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_get_nstringz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a stringz (NUL-terminated string) in tvbuff and copies no more than bufsize number of bytes, including terminating NUL, to buffer. Returns length of string (not including terminating NUL), or -1 if the string was truncated in the buffer due to not having reached the terminating NUL. In this way, it acts like g_snprintf().</p>
<p>When processing a packet where the remaining number of bytes is less than bufsize, an exception is not thrown if the end of the packet is reached before the NUL is found. If no NUL is found before reaching the end of the short packet, -1 is still returned, and the string is truncated with a NUL, albeit not at buffer[bufsize - 1], but at the correct spot, terminating the string. </p>

</div>
</div>
<a class="anchor" id="a8e059fc6e4a335080cb59d03843c1bb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_get_nstringz0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="tvbuff_8h.html#a37a611d5fba78483ca46b1e4b7c8327b">tvb_get_nstringz()</a>, but never returns -1. The string is guaranteed to have a terminating NUL. If the string was truncated when copied into buffer, a NUL is placed at the end of buffer to terminate it.</p>
<p>bufsize MUST be greater than 0. </p>

</div>
</div>
<a class="anchor" id="ae83005861c45fae75b73685fb06192e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const guint8* tvb_get_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WARNING! This function is possibly expensive, temporarily allocating another copy of the packet data. Furthermore, it's dangerous because once this pointer is given to the user, there's no guarantee that the user will honor the 'length' and not overstep the boundaries of the buffer.</p>
<p>The returned pointer is data that is internal to the tvbuff, so do not attempt to free it. Don't modify the data, either, because another tvbuff that might be using this tvbuff may have already copied that portion of the data (sometimes tvbuff's need to make copies of data, but that's the internal implementation that you need not worry about). Assume that the guint8* points to read-only data that the tvbuff manages.</p>
<p>Return a pointer into our buffer if the data asked for via 'offset'/'length' is contiguous (which might not be the case for TVBUFF_COMPOSITE). If the data is not contiguous, a <a class="el" href="tvbuff_8h.html#a3308c19cf00a7aabfe3c327589d0ec42">tvb_memdup()</a> is called for the entire buffer and the pointer to the newly-contiguous data is returned. This dynamically- allocated memory will be freed when the tvbuff is freed, after the tvbuff_free_cb_t() is called, if any. </p>

</div>
</div>
<a class="anchor" id="ac9ad9b5546ebe7050b769df02298ad58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint8* tvb_get_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a tvbuff, an offset, and a length, allocate a buffer big enough to hold a non-null-terminated string of that length at that offset, plus a trailing zero, copy the string into it, and return a pointer to the string.</p>
<p>Throws an exception if the tvbuff ends before the string does.</p>
<p><a class="el" href="tvbuff_8h.html#ac9ad9b5546ebe7050b769df02298ad58">tvb_get_string()</a> returns a string allocated by g_malloc() and therefore MUST be g_free() by the caller in order not to leak memory.</p>
<p>tvb_get_ephemeral_string() returns a string that does not need to be freed, instead it will automatically be freed once the next packet is dissected. </p>

</div>
</div>
<a class="anchor" id="af831b2d20a4964fab41f4c4781611ea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint8* tvb_get_stringz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint *&#160;</td>
          <td class="paramname"><em>lengthp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a tvbuff and an offset, with the offset assumed to refer to a null-terminated string, find the length of that string (and throw an exception if the tvbuff ends before we find the null), allocate a buffer big enough to hold the string, copy the string into it, and return a pointer to the string. Also return the length of the string (including the terminating null) through a pointer.</p>
<p><a class="el" href="tvbuff_8h.html#af831b2d20a4964fab41f4c4781611ea0">tvb_get_stringz()</a> returns a string allocated by g_malloc() and therefore MUST be g_free() by the caller in order not to leak memory.</p>
<p>tvb_get_ephemeral_stringz() returns a string that does not need to be freed, instead it will automatically be freed once the next packet is dissected. </p>

</div>
</div>
<a class="anchor" id="a47dbbdfd540b824f17c035f0663f119f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint tvb_increment_usage_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Both return the new usage count, after the increment or decrement </p>

</div>
</div>
<a class="anchor" id="aab9cc505773f07f1932f9204777ac8f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_length_remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes bytes to end of buffer, from offset (which can be negative, to indicate bytes from end of buffer). Function returns -1 to indicate that offset is out of bounds. No exception is thrown. </p>

</div>
</div>
<a class="anchor" id="abe01bb7439c8f77a02727c4bef62e56c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tvb_memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns target for convenience. Does not suffer from possible expense of <a class="el" href="tvbuff_8h.html#ae83005861c45fae75b73685fb06192e9">tvb_get_ptr()</a>, since this routine is smart enough to copy data in chunks if the request range actually exists in different TVBUFF_REAL_DATA tvbuffs. This function assumes that the target memory is already allocated; it does not allocate or free the target memory. </p>

</div>
</div>
<a class="anchor" id="a3308c19cf00a7aabfe3c327589d0ec42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tvb_memdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It is the user's responsibility to g_free() the memory allocated by <a class="el" href="tvbuff_8h.html#a3308c19cf00a7aabfe3c327589d0ec42">tvb_memdup()</a>. Calls <a class="el" href="tvbuff_8h.html#abe01bb7439c8f77a02727c4bef62e56c">tvb_memcpy()</a> </p>

</div>
</div>
<a class="anchor" id="a36912d356ceaae18c4647b700647c0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_memeql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const guint8 *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call memcmp after checking if enough chars left, returning 0 if it returns 0 (meaning "equal") and -1 otherwise, otherwise return -1. </p>

</div>
</div>
<a class="anchor" id="ac3fae01a75f429ddf3a1d1f4d6d3dcfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtvbuff.html">tvbuff_t</a>* tvb_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tvbuff_8h.html#a9e46572a63e9cfa8f496c7fead8a4320">tvbuff_type</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to a newly initialized tvbuff. Note that tvbuff's of types TVBUFF_SUBSET and TVBUFF_COMPOSITE require further initialization via the appropriate functions </p>

</div>
</div>
<a class="anchor" id="aaa919b43fdba78f4be4a76aa274e6cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtvbuff.html">tvbuff_t</a>* tvb_new_composite </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function that calls tvb_new(TVBUFF_COMPOSITE). Provided only to maintain symmetry with other constructors </p>

</div>
</div>
<a class="anchor" id="ad1be3270c3897c6c5e688b8f96a0324b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtvbuff.html">tvbuff_t</a>* tvb_new_real_data </td>
          <td>(</td>
          <td class="paramtype">const guint8 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>reported_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combination of <a class="el" href="tvbuff_8h.html#ac3fae01a75f429ddf3a1d1f4d6d3dcfd">tvb_new()</a> and <a class="el" href="tvbuff_8h.html#a81ed1a2cb684d94c639344da11e46aa9">tvb_set_real_data()</a>. Can throw ReportedBoundsError. </p>

</div>
</div>
<a class="anchor" id="a94052a5a6ddf1629173d426746e7ed13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtvbuff.html">tvbuff_t</a>* tvb_new_subset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>backing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>backing_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>backing_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>reported_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combination of <a class="el" href="tvbuff_8h.html#ac3fae01a75f429ddf3a1d1f4d6d3dcfd">tvb_new()</a> and <a class="el" href="tvbuff_8h.html#a083d74786a89289b31e3909350f0f100">tvb_set_subset()</a> Can throw ReportedBoundsError. </p>

</div>
</div>
<a class="anchor" id="a94ad57c39979942fed7bf8beaca09aa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_pbrk_guint8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const guint8 *&#160;</td>
          <td class="paramname"><em>needles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find first occurence of any of the needles in tvbuff, starting at offset. Searches at most maxlength number of bytes. Returns the offset of the found needle, or -1 if not found. Will not throw an exception, even if maxlength exceeds boundary of tvbuff; in that case, -1 will be returned if the boundary is reached before finding needle. </p>

</div>
</div>
<a class="anchor" id="a0ff6d1c9ee0d773fc88d2a3cbe7fb2b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_reported_length_remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes bytes of reported packet data to end of buffer, from offset (which can be negative, to indicate bytes from end of buffer). Function returns -1 to indicate that offset is out of bounds. No exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a6d2c676a6ac7889b4a4d1f586177fc0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_set_child_real_data_tvbuff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach a TVBUFF_REAL_DATA tvbuff to a parent tvbuff. This connection is used during a <a class="el" href="tvbuff_8h.html#a3788ab7eafa812c9d73d2ebe403c15c1">tvb_free_chain()</a>... the "child" TVBUFF_REAL_DATA acts as if is part of the chain-of-creation of the parent tvbuff, although it isn't. This is useful if you need to take the data from some tvbuff, run some operation on it, like decryption or decompression, and make a new tvbuff from it, yet want the new tvbuff to be part of the chain. The reality is that the new tvbuff <em>is</em> part of the "chain of creation", but in a way that these tvbuff routines is ignorant of. Use this function to make the tvbuff routines knowledgable of this fact. </p>

</div>
</div>
<a class="anchor" id="a5964b79a9b99108a2300ac5b137423d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_set_free_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tvbuff_free_cb_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a callback function to call when a tvbuff is actually freed (once the usage count drops to 0). One argument is passed to that callback &mdash; a void* that points to the real data. Obviously, this only applies to a TVBUFF_REAL_DATA tvbuff. </p>

</div>
</div>
<a class="anchor" id="a81ed1a2cb684d94c639344da11e46aa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_set_real_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const guint8 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>reported_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets parameters for TVBUFF_REAL_DATA. Can throw ReportedBoundsError. </p>

</div>
</div>
<a class="anchor" id="a73b02b4fbab1fd6fbeff362448bcd0f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_set_reported_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the reported length of a tvbuff to a given value; used for protocols whose headers contain an explicit length and where the calling dissector's payload may include padding as well as the packet for this protocol.</p>
<p>Also adjusts the data length. </p>

</div>
</div>
<a class="anchor" id="a083d74786a89289b31e3909350f0f100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvb_set_subset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>backing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>backing_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>backing_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>reported_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define the subset of the backing buffer to use.</p>
<p>'backing_offset' can be negative, to indicate bytes from the end of the backing buffer.</p>
<p>'backing_length' can be 0, although the usefulness of the buffer would be rather limited.</p>
<p>'backing_length' of -1 means "to the end of the backing buffer"</p>
<p>Will throw BoundsError if 'backing_offset'/'length' is beyond the bounds of the backing tvbuff. Can throw ReportedBoundsError. </p>

</div>
</div>
<a class="anchor" id="a15e63caa7926ccb13c62db3ce6c294c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_skip_wsp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>maxlength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copied from the mgcp dissector. (This function should be moved to /epan ) tvb_skip_wsp - Returns the position in tvb of the first non-whitespace character following offset or offset + maxlength -1 whichever is smaller.</p>
<p>Parameters: tvb - The tvbuff in which we are skipping whitespace. offset - The offset in tvb from which we begin trying to skip whitespace. maxlength - The maximum distance from offset that we may try to skip whitespace.</p>
<p>Returns: The position in tvb of the first non-whitespace character following offset or offset + maxlength -1 whichever is smaller. </p>

</div>
</div>
<a class="anchor" id="a8f0ec59e419e99c74d393c1597ff46f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_strncaseeql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call g_ascii_strncasecmp after checking if enough chars left, returning 0 if it returns 0 (meaning "equal") and -1 otherwise, otherwise return -1. </p>

</div>
</div>
<a class="anchor" id="ad3291b012a0e6d15cee9a0460723cd92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_strneql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call strncmp after checking if enough chars left, returning 0 if it returns 0 (meaning "equal") and -1 otherwise, otherwise return -1. </p>

</div>
</div>
<a class="anchor" id="a27da69ebed5c60023d054da0e475b2a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint tvb_strnlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>maxlength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find length of string by looking for end of zero terminated string, up to 'maxlength' characters'; if 'maxlength' is -1, searches to end of tvbuff. Returns -1 if 'maxlength' reached before finding EOS. </p>

</div>
</div>
<a class="anchor" id="aec98961ab4a0e137d107943ab80cb532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint tvb_strsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find size of stringz (NUL-terminated string) by looking for terminating NUL. The size of the string includes the terminating NUL.</p>
<p>If the NUL isn't found, it throws the appropriate exception. </p>

</div>
</div>
<a class="anchor" id="ae2a1330890fd1debb533e0b3f37bc9cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtvbuff.html">tvbuff_t</a>* tvb_uncompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvbuff.html">tvbuff_t</a> *&#160;</td>
          <td class="paramname"><em>tvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comprlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uncompresses a zlib compressed packet inside a tvbuff at offset with length comprlen. Returns an uncompressed tvbuffer if uncompression succeeded or NULL if uncompression failed. </p>

</div>
</div>
<a class="anchor" id="ac230490546afc3c91d1460ee75605b6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvbuff_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>"class" cleanup. Called once during execution of program so that tvbuff.c can clean up its data. </p>

</div>
</div>
<a class="anchor" id="a6470945c7d80497cc773c5564c8f6355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvbuff_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TVBUFF_REAL_DATA contains a guint8* that points to real data. The data is allocated and contiguous.</p>
<p>TVBUFF_SUBSET has a backing tvbuff. The TVBUFF_SUBSET is a "window" through which the program sees only a portion of the backing tvbuff.</p>
<p>TVBUFF_COMPOSITE combines multiple tvbuffs sequentually to produce a larger byte array.</p>
<p>tvbuff's of any type can be used as the backing-tvbuff of a TVBUFF_SUBSET or as the member of a TVBUFF_COMPOSITE. TVBUFF_COMPOSITEs can have member-tvbuffs of different types.</p>
<p>Once a tvbuff is create/initialized/finalized, the tvbuff is read-only. That is, it cannot point to any other data. A new tvbuff must be created if you want a tvbuff that points to other data. "class" initialization. Called once during execution of program so that tvbuff.c can initialize its data. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_23c7da0613bb292e7b270038d6b3494b.html">cbench</a></li><li class="navelem"><a class="el" href="dir_ee6061629cac7ac06a3414bd31efbc8b.html">openflow</a></li><li class="navelem"><a class="el" href="dir_d643d61087216b70fb9b20fa862234ff.html">utilities</a></li><li class="navelem"><a class="el" href="dir_15fbfb164ebeede7a3a39368a7f807ea.html">wireshark_dissectors</a></li><li class="navelem"><a class="el" href="dir_b8cec8f0f55f3a81a0a2b647f3122610.html">wireshark-1.0.0-includes</a></li><li class="navelem"><a class="el" href="dir_c88a3ab5468b2f547fa1702390f3958e.html">epan</a></li><li class="navelem"><a class="el" href="tvbuff_8h.html">tvbuff.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
